// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// SMC Order Block Scalping Strategy - 5min TF optimized
// TP1: 1:1 RR (50% close) = 1% equity, TP2: 1.5:1 RR (50% close) = 1.5% equity
// Total if both TPs hit: 2.5% equity gain | SL moves to BE after TP1
// Dynamic Position Sizing: Risk exactly X% per trade
//@version=6
strategy("SMC OB Scalper v2", overlay=true, default_qty_type=strategy.cash, default_qty_value=100, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.06, calc_on_every_tick=false, process_orders_on_close=true, margin_long=5, margin_short=5)

//=============================================================================
// INPUTS - Risk Management (Margin + Leverage Based)
//=============================================================================
grp_risk = "Risk Management"
i_margin_pct    = input.float(10.0, "Margin % of Equity", minval=1, maxval=20, step=0.5, group=grp_risk, tooltip="How much of equity to use as margin (e.g., 10%)")
i_sl_loss_pct   = input.float(20.0, "SL Loss % of Position", minval=10, maxval=90, step=5, group=grp_risk, tooltip="At SL, lose this % of position (e.g., 20%). Max equity loss = Margin% × SL Loss%")
i_max_leverage  = input.float(50.0, "Max Leverage", minval=5, maxval=125, step=5, group=grp_risk, tooltip="Cap leverage (Bybit max is usually 50-125x)")
i_direction     = input.string("Both", "Trade Direction", options=["Long", "Short", "Both"], group=grp_risk)

// Calculated: Max equity loss per trade = Margin% × SL Loss% = 10% × 20% = 2%

//=============================================================================
// INPUTS - Strategy Settings (Scalping Optimized)
//=============================================================================
grp_strat = "Strategy Settings"
i_sl_buffer     = input.float(0.05, "SL Buffer %", minval=0.0, maxval=1.0, step=0.01, group=grp_strat, tooltip="Buffer below OB for Long SL, above OB for Short SL")
i_min_sl_pct    = input.float(0.15, "Min SL Distance %", minval=0.05, maxval=1.0, step=0.05, group=grp_strat, tooltip="Minimum SL distance as % of price - prevents tiny trades")
i_max_ob_age    = input.int(20, "Max OB Age (bars)", minval=5, maxval=100, group=grp_strat, tooltip="OBs older than this are ignored")

// Take Profit Settings (Fixed RR)
grp_tp = "Take Profit Settings"
i_tp1_rr        = input.float(1.0, "TP1 Risk:Reward", minval=0.5, maxval=3.0, step=0.1, group=grp_tp, tooltip="TP1 at 1:1 RR → 1% equity gain (50% of 2% risk)")
i_tp1_pct       = input.float(50, "TP1 Position %", minval=10, maxval=90, step=10, group=grp_tp, tooltip="Close 50% at TP1")
i_tp2_rr        = input.float(1.5, "TP2 Risk:Reward", minval=1.0, maxval=5.0, step=0.1, group=grp_tp, tooltip="TP2 at 1.5:1 RR → 1.5% equity gain (50% of 2% risk)")
i_move_sl_be    = input.bool(true, "Move SL to BE after TP1", group=grp_tp)

//=============================================================================
// INPUTS - Order Block Settings
//=============================================================================
grp_ob = "Order Block Settings"
i_ob_show       = input.bool(true, "Show Order Blocks", group=grp_ob)
i_ob_num        = input.int(3, "Max Order Blocks", minval=1, maxval=10, group=grp_ob)
i_ob_strength   = input.float(0.8, "Min OB Strength", minval=0.5, maxval=1.0, step=0.05, group=grp_ob, tooltip="Higher = stronger OBs only")
i_ob_mitigation = input.string("Close", "Mitigation Method", options=["Touch", "Wick", "Close"], group=grp_ob)
i_internal_len  = input.int(5, "Internal Structure Length", minval=2, maxval=20, group=grp_ob)

// OB Colors
i_ob_bull_css   = input.color(color.new(#089981, 80), "Bullish OB Color", group=grp_ob)
i_ob_bear_css   = input.color(color.new(#f23645, 80), "Bearish OB Color", group=grp_ob)

//=============================================================================
// INPUTS - MTF (Multi-Timeframe) Filter
//=============================================================================
grp_mtf = "MTF Trend Filter"
i_use_1h_mtf    = input.bool(true, "Use 1H Trend Filter", group=grp_mtf)
i_use_4h_mtf    = input.bool(false, "Use 4H Trend Filter", group=grp_mtf)
i_use_daily_mtf = input.bool(false, "Use Daily Trend Filter", group=grp_mtf)
i_ema_fast      = input.int(20, "Fast EMA", minval=5, maxval=50, group=grp_mtf)
i_ema_slow      = input.int(50, "Slow EMA", minval=20, maxval=200, group=grp_mtf)

//=============================================================================
// INPUTS - External Indicator Filters (Connect your own indicators!)
//=============================================================================
grp_ext = "External Indicator Filters"
i_use_ext1      = input.bool(false, "Use External Filter 1", group=grp_ext)
i_ext1_source   = input.source(close, "Ext 1 Source", group=grp_ext)
i_ext1_compare  = input.string("Greater Than", "Ext 1 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext1_value    = input.float(0, "Ext 1 Value", group=grp_ext)

i_use_ext2      = input.bool(false, "Use External Filter 2", group=grp_ext)
i_ext2_source   = input.source(close, "Ext 2 Source", group=grp_ext)
i_ext2_compare  = input.string("Greater Than", "Ext 2 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext2_value    = input.float(0, "Ext 2 Value", group=grp_ext)

i_use_ext3      = input.bool(false, "Use External Filter 3", group=grp_ext)
i_ext3_source   = input.source(close, "Ext 3 Source", group=grp_ext)
i_ext3_compare  = input.string("Greater Than", "Ext 3 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext3_value    = input.float(0, "Ext 3 Value", group=grp_ext)

//=============================================================================
// INPUTS - Time Filter
//=============================================================================
grp_time = "Time Filter"
i_use_time      = input.bool(false, "Use Time Filter", group=grp_time)
i_start_hour    = input.int(8, "Start Hour (UTC)", minval=0, maxval=23, group=grp_time)
i_end_hour      = input.int(20, "End Hour (UTC)", minval=0, maxval=23, group=grp_time)

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

// External condition checker
checkExtCondition(float src, string cond, float val) =>
    result = true
    if cond == "Greater Than"
        result := src > val
    else if cond == "Less Than"
        result := src < val
    else if cond == "Equals"
        result := math.abs(src - val) < 0.0001
    else if cond == "Crosses Above"
        result := ta.crossover(src, val)
    else if cond == "Crosses Below"
        result := ta.crossunder(src, val)
    result

// Check all external filters
checkExternalFilters() =>
    ext1_ok = i_use_ext1 ? checkExtCondition(i_ext1_source, i_ext1_compare, i_ext1_value) : true
    ext2_ok = i_use_ext2 ? checkExtCondition(i_ext2_source, i_ext2_compare, i_ext2_value) : true
    ext3_ok = i_use_ext3 ? checkExtCondition(i_ext3_source, i_ext3_compare, i_ext3_value) : true
    ext1_ok and ext2_ok and ext3_ok

// Time filter
inTradingHours() =>
    if i_use_time
        hour >= i_start_hour and hour < i_end_hour
    else
        true

//=============================================================================
// POSITION SIZE CALCULATION (Margin + Dynamic Leverage)
//=============================================================================
// User sets: Margin % (e.g., 10%) and SL Loss % (e.g., 20%)
// System calculates: Leverage needed so that SL hit = Margin% × SL Loss% of equity
//
// Example: Margin=10%, SL Loss=20%, Equity=$1000
// - Margin used: $100
// - Max loss at SL: $100 × 20% = $20 = 2% of equity
// - If SL is 1% from entry → need 20x leverage (safer than 50x!)
// - If SL is 2% from entry → need 10x leverage

calcPositionSize(float entry_price, float sl_price) =>
    equity = strategy.equity

    // Fixed margin amount
    margin = equity * (i_margin_pct / 100)

    // Calculate SL distance as % of entry
    sl_distance = math.abs(entry_price - sl_price)
    sl_distance_pct = sl_distance / entry_price * 100

    // Calculate required leverage to achieve target SL loss %
    // Formula: sl_distance_pct × leverage = i_sl_loss_pct
    // So: leverage = i_sl_loss_pct / sl_distance_pct
    required_leverage = sl_distance_pct > 0 ? i_sl_loss_pct / sl_distance_pct : 0

    // Cap leverage at max
    leverage = math.min(required_leverage, i_max_leverage)

    // If capped, the actual SL loss % will be lower (safer)
    actual_sl_loss_pct = sl_distance_pct * leverage

    // Calculate position value and quantity
    position_value = margin * leverage
    qty = position_value / entry_price

    // Calculate actual risk in currency (for display)
    // risk_amount = margin × actual_sl_loss_pct / 100
    risk_amount = margin * (actual_sl_loss_pct / 100)

    [qty, leverage, position_value, margin, actual_sl_loss_pct, risk_amount]

// Track calculated values for display
var float active_qty = na
var float active_leverage = na
var float active_position_value = na
var float active_margin = na
var float active_sl_loss_pct = na
var float active_risk_amount = na

//=============================================================================
// MTF TREND DETECTION
//=============================================================================

// Current timeframe EMAs
ema_fast = ta.ema(close, i_ema_fast)
ema_slow = ta.ema(close, i_ema_slow)

// 1H Trend
[h1_close, h1_ema20, h1_ema50] = request.security(syminfo.tickerid, "60", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
h1_bullish = h1_close > h1_ema20 and h1_ema20 > h1_ema50
h1_bearish = h1_close < h1_ema20 and h1_ema20 < h1_ema50

// 4H Trend
[h4_close, h4_ema20, h4_ema50] = request.security(syminfo.tickerid, "240", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
h4_bullish = h4_close > h4_ema20 and h4_ema20 > h4_ema50
h4_bearish = h4_close < h4_ema20 and h4_ema20 < h4_ema50

// Daily Trend
[d_close, d_ema20, d_ema50] = request.security(syminfo.tickerid, "D", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
d_bullish = d_close > d_ema20 and d_ema20 > d_ema50
d_bearish = d_close < d_ema20 and d_ema20 < d_ema50

// Combined MTF Filter
mtf_long_ok() =>
    h1_ok = i_use_1h_mtf ? h1_bullish : true
    h4_ok = i_use_4h_mtf ? h4_bullish : true
    d_ok  = i_use_daily_mtf ? d_bullish : true
    h1_ok and h4_ok and d_ok

mtf_short_ok() =>
    h1_ok = i_use_1h_mtf ? h1_bearish : true
    h4_ok = i_use_4h_mtf ? h4_bearish : true
    d_ok  = i_use_daily_mtf ? d_bearish : true
    h1_ok and h4_ok and d_ok

//=============================================================================
// ORDER BLOCK DETECTION (Simplified from LuxAlgo)
//=============================================================================

// Swing detection
iH = ta.pivothigh(high, i_internal_len, i_internal_len)
iL = ta.pivotlow(low, i_internal_len, i_internal_len)

// Track internal structure
var int itrend = 0
var float last_swing_high = na
var float last_swing_low = na
var int last_swing_high_bar = na
var int last_swing_low_bar = na

// Update swing points
if not na(iH)
    last_swing_high := high[i_internal_len]
    last_swing_high_bar := bar_index - i_internal_len

if not na(iL)
    last_swing_low := low[i_internal_len]
    last_swing_low_bar := bar_index - i_internal_len

// CRITICAL: Reset swing points if they become too old (prevents historical buffer error)
// Max historical buffer in Pine Script is 300, so we reset at 150 to be safe
if not na(last_swing_high_bar) and (bar_index - last_swing_high_bar) > 150
    last_swing_high_bar := na
    last_swing_high := na

if not na(last_swing_low_bar) and (bar_index - last_swing_low_bar) > 150
    last_swing_low_bar := na
    last_swing_low := na

// Detect structure breaks
bull_break = ta.crossover(close, last_swing_high) and not na(last_swing_high)
bear_break = ta.crossunder(close, last_swing_low) and not na(last_swing_low)

// Update trend
if bull_break
    itrend := 1
if bear_break
    itrend := -1

//=============================================================================
// ORDER BLOCK STORAGE
//=============================================================================

// Order Block arrays
var array<float> bull_ob_top = array.new_float(0)
var array<float> bull_ob_btm = array.new_float(0)
var array<int> bull_ob_bar = array.new_int(0)
var array<float> bull_ob_strength = array.new_float(0)

var array<float> bear_ob_top = array.new_float(0)
var array<float> bear_ob_btm = array.new_float(0)
var array<int> bear_ob_bar = array.new_int(0)
var array<float> bear_ob_strength = array.new_float(0)

// Calculate OB strength - now checks for impulsive move AFTER the OB candle
calcOBStrength(int ob_idx) =>
    // Check if the move after OB was impulsive (big candle, high volume)
    // IMPORTANT: Add bounds check to avoid historical buffer error (max 145 to be safe)
    if ob_idx > 0 and ob_idx < 145
        // The candle after OB should be impulsive
        impulse_candle_size = math.abs(close[ob_idx - 1] - open[ob_idx - 1])
        avg_candle_size = ta.sma(math.abs(close - open), 20)
        vol_ratio = volume[ob_idx - 1] / ta.sma(volume, 20)

        // Impulse should be at least 1.5x average size
        size_ratio = impulse_candle_size / avg_candle_size
        strength = math.min(1.0, (size_ratio * 0.4 + vol_ratio * 0.3))
        strength
    else
        0.0

// Check if candle is bearish (for bullish OB)
isBearishCandle(int idx) =>
    close[idx] < open[idx]

// Check if candle is bullish (for bearish OB)
isBullishCandle(int idx) =>
    close[idx] > open[idx]

//=============================================================================
// CORRECT ORDER BLOCK DETECTION
// Bullish OB = Last BEARISH candle BEFORE the swing low that was broken
// Bearish OB = Last BULLISH candle BEFORE the swing high that was broken
// KEY FIX: Look back from the SWING POINT, not from current bar!
//=============================================================================

// Create bullish OB on structure break (price breaks above swing high)
// CRITICAL: Double-check swing age to prevent historical buffer error
swing_low_age = na(last_swing_low_bar) ? 9999 : bar_index - last_swing_low_bar
if bull_break and not na(last_swing_low_bar) and swing_low_age < 150
    // Calculate how many bars ago the swing LOW was formed (that's where the impulse started)
    bars_since_swing = swing_low_age

    // IMPORTANT: Cap to avoid "historical buffer limit" error (max is 300)
    // Skip if swing is too old
    if bars_since_swing > 0 and bars_since_swing < 150
        // Find the LAST BEARISH CANDLE before the swing low (this is the real OB!)
        ob_found = false
        ob_idx = 0

        // Start from the swing low and look backwards (max 20 bars before swing)
        // The OB is the candle that "loaded up" before the impulse move
        max_lookback = math.min(bars_since_swing + 20, 140)
        for i = bars_since_swing to max_lookback
            if i > 0 and i < 145 and isBearishCandle(i) and not ob_found
                ob_idx := i
                ob_found := true
                break

        if ob_found and ob_idx > 0 and ob_idx < 145
            // The Order Block is the BODY of the last bearish candle
            ob_top = math.max(open[ob_idx], close[ob_idx])  // Body high (open for bearish)
            ob_btm = low[ob_idx]  // Include the wick for SL
            ob_str = calcOBStrength(ob_idx)

            // Only add if OB is below current price (valid for retest entry)
            if ob_str >= i_ob_strength and ob_top < close
                array.unshift(bull_ob_top, ob_top)
                array.unshift(bull_ob_btm, ob_btm)
                array.unshift(bull_ob_bar, bar_index - ob_idx)
                array.unshift(bull_ob_strength, ob_str)

                // Limit array size
                if array.size(bull_ob_top) > i_ob_num
                    array.pop(bull_ob_top)
                    array.pop(bull_ob_btm)
                    array.pop(bull_ob_bar)
                    array.pop(bull_ob_strength)

// Create bearish OB on structure break (price breaks below swing low)
// CRITICAL: Double-check swing age to prevent historical buffer error
swing_high_age = na(last_swing_high_bar) ? 9999 : bar_index - last_swing_high_bar
if bear_break and not na(last_swing_high_bar) and swing_high_age < 150
    // Calculate how many bars ago the swing HIGH was formed (that's where the impulse started)
    bars_since_swing = swing_high_age

    // IMPORTANT: Cap to avoid "historical buffer limit" error (max is 300)
    // Skip if swing is too old
    if bars_since_swing > 0 and bars_since_swing < 150
        // Find the LAST BULLISH CANDLE before the swing high (this is the real OB!)
        ob_found = false
        ob_idx = 0

        // Start from the swing high and look backwards (max 20 bars before swing)
        max_lookback = math.min(bars_since_swing + 20, 140)
        for i = bars_since_swing to max_lookback
            if i > 0 and i < 145 and isBullishCandle(i) and not ob_found
                ob_idx := i
                ob_found := true
                break

        if ob_found and ob_idx > 0 and ob_idx < 145
            // The Order Block is the BODY of the last bullish candle
            ob_top = high[ob_idx]  // Include the wick for SL
            ob_btm = math.min(open[ob_idx], close[ob_idx])  // Body low (open for bullish)
            ob_str = calcOBStrength(ob_idx)

            // Only add if OB is above current price (valid for retest entry)
            if ob_str >= i_ob_strength and ob_btm > close
                array.unshift(bear_ob_top, ob_top)
                array.unshift(bear_ob_btm, ob_btm)
                array.unshift(bear_ob_bar, bar_index - ob_idx)
                array.unshift(bear_ob_strength, ob_str)

                // Limit array size
                if array.size(bear_ob_top) > i_ob_num
                    array.pop(bear_ob_top)
                    array.pop(bear_ob_btm)
                    array.pop(bear_ob_bar)
                    array.pop(bear_ob_strength)

//=============================================================================
// ORDER BLOCK MITIGATION & ENTRY SIGNALS
//=============================================================================

// Check for bullish OB entry (price touches bullish OB from above)
var int active_bull_ob_idx = -1
var float bull_entry = na
var float bull_sl = na
var float bull_tp1 = na
var float bull_tp2 = na
var float bull_qty = na

bull_ob_signal = false
if array.size(bull_ob_top) > 0 and strategy.position_size == 0
    for i = 0 to array.size(bull_ob_top) - 1
        ob_top = array.get(bull_ob_top, i)
        ob_btm = array.get(bull_ob_btm, i)
        ob_bar = array.get(bull_ob_bar, i)
        ob_age = bar_index - ob_bar

        // Check if price is touching OB and OB is not too old
        price_in_ob = low <= ob_top and close > ob_btm
        ob_valid = ob_age <= i_max_ob_age

        if price_in_ob and ob_valid and not bull_ob_signal
            // Check mitigation method
            entry_trigger = false
            if i_ob_mitigation == "Touch"
                entry_trigger := low <= ob_top
            else if i_ob_mitigation == "Wick"
                entry_trigger := low <= ob_top and close > ob_top
            else if i_ob_mitigation == "Close"
                entry_trigger := close <= ob_top and close >= ob_btm

            if entry_trigger
                bull_ob_signal := true
                active_bull_ob_idx := i
                bull_entry := close  // Entry at current close
                bull_sl := ob_btm * (1 - i_sl_buffer/100)  // SL below OB + buffer

                // Calculate SL distance - use minimum if too small
                raw_sl_dist = bull_entry - bull_sl
                min_sl_dist = bull_entry * (i_min_sl_pct / 100)
                sl_dist = math.max(raw_sl_dist, min_sl_dist)

                // If raw distance was too small, adjust SL to match
                if raw_sl_dist < min_sl_dist
                    bull_sl := bull_entry - min_sl_dist

                bull_tp1 := bull_entry + (sl_dist * i_tp1_rr)  // TP1 at RR
                bull_tp2 := bull_entry + (sl_dist * i_tp2_rr)  // TP2 at RR

                // Calculate position size based on margin + dynamic leverage
                [qty, lev, pos_val, margin, sl_loss, risk_amt] = calcPositionSize(bull_entry, bull_sl)
                bull_qty := qty
                break

// Check for bearish OB entry (price touches bearish OB from below)
var int active_bear_ob_idx = -1
var float bear_entry = na
var float bear_sl = na
var float bear_tp1 = na
var float bear_tp2 = na
var float bear_qty = na

bear_ob_signal = false
if array.size(bear_ob_top) > 0 and strategy.position_size == 0
    for i = 0 to array.size(bear_ob_top) - 1
        ob_top = array.get(bear_ob_top, i)
        ob_btm = array.get(bear_ob_btm, i)
        ob_bar = array.get(bear_ob_bar, i)
        ob_age = bar_index - ob_bar

        // Check if price is touching OB and OB is not too old
        price_in_ob = high >= ob_btm and close < ob_top
        ob_valid = ob_age <= i_max_ob_age

        if price_in_ob and ob_valid and not bear_ob_signal
            // Check mitigation method
            entry_trigger = false
            if i_ob_mitigation == "Touch"
                entry_trigger := high >= ob_btm
            else if i_ob_mitigation == "Wick"
                entry_trigger := high >= ob_btm and close < ob_btm
            else if i_ob_mitigation == "Close"
                entry_trigger := close >= ob_btm and close <= ob_top

            if entry_trigger
                bear_ob_signal := true
                active_bear_ob_idx := i
                bear_entry := close  // Entry at current close
                bear_sl := ob_top * (1 + i_sl_buffer/100)  // SL above OB + buffer

                // Calculate SL distance - use minimum if too small
                raw_sl_dist = bear_sl - bear_entry
                min_sl_dist = bear_entry * (i_min_sl_pct / 100)
                sl_dist = math.max(raw_sl_dist, min_sl_dist)

                // If raw distance was too small, adjust SL to match
                if raw_sl_dist < min_sl_dist
                    bear_sl := bear_entry + min_sl_dist

                bear_tp1 := bear_entry - (sl_dist * i_tp1_rr)  // TP1 at RR
                bear_tp2 := bear_entry - (sl_dist * i_tp2_rr)  // TP2 at RR

                // Calculate position size based on margin + dynamic leverage
                [qty, lev, pos_val, margin, sl_loss, risk_amt] = calcPositionSize(bear_entry, bear_sl)
                bear_qty := qty
                break

//=============================================================================
// ENTRY CONDITIONS
//=============================================================================

// Final long condition
long_condition = bull_ob_signal and
                 (i_direction == "Long" or i_direction == "Both") and
                 mtf_long_ok() and
                 checkExternalFilters() and
                 inTradingHours() and
                 strategy.position_size == 0

// Final short condition
short_condition = bear_ob_signal and
                  (i_direction == "Short" or i_direction == "Both") and
                  mtf_short_ok() and
                  checkExternalFilters() and
                  inTradingHours() and
                  strategy.position_size == 0

//=============================================================================
// STRATEGY EXECUTION
//=============================================================================

// Track position state
var bool tp1_taken = false
var float active_entry = na
var float active_sl = na
var float active_tp1 = na
var float active_tp2 = na
var bool is_long = false

// Entry: Long with calculated position size
if long_condition and bull_qty > 0
    strategy.entry("Long", strategy.long, qty=bull_qty)
    active_entry := bull_entry
    active_sl := bull_sl
    active_tp1 := bull_tp1
    active_tp2 := bull_tp2
    tp1_taken := false
    is_long := true

    // Store for display - recalculate to get all values
    [q, lev, pos_val, marg, sl_loss, risk_amt] = calcPositionSize(bull_entry, bull_sl)
    active_qty := bull_qty
    active_leverage := lev
    active_position_value := pos_val
    active_margin := marg
    active_sl_loss_pct := sl_loss
    active_risk_amount := risk_amt

    // Remove used OB
    if active_bull_ob_idx >= 0 and active_bull_ob_idx < array.size(bull_ob_top)
        array.remove(bull_ob_top, active_bull_ob_idx)
        array.remove(bull_ob_btm, active_bull_ob_idx)
        array.remove(bull_ob_bar, active_bull_ob_idx)
        array.remove(bull_ob_strength, active_bull_ob_idx)

// Entry: Short with calculated position size
if short_condition and bear_qty > 0
    strategy.entry("Short", strategy.short, qty=bear_qty)
    active_entry := bear_entry
    active_sl := bear_sl
    active_tp1 := bear_tp1
    active_tp2 := bear_tp2
    tp1_taken := false
    is_long := false

    // Store for display - recalculate to get all values
    [q, lev, pos_val, marg, sl_loss, risk_amt] = calcPositionSize(bear_entry, bear_sl)
    active_qty := bear_qty
    active_leverage := lev
    active_position_value := pos_val
    active_margin := marg
    active_sl_loss_pct := sl_loss
    active_risk_amount := risk_amt

    // Remove used OB
    if active_bear_ob_idx >= 0 and active_bear_ob_idx < array.size(bear_ob_top)
        array.remove(bear_ob_top, active_bear_ob_idx)
        array.remove(bear_ob_btm, active_bear_ob_idx)
        array.remove(bear_ob_bar, active_bear_ob_idx)
        array.remove(bear_ob_strength, active_bear_ob_idx)

//=============================================================================
// EXIT LOGIC: TP1 (50%) + TP2 (50%) + Dynamic SL → BE after TP1
// Simple approach: Set ALL exits from start, only update SL after TP1
//=============================================================================

// Track initial position size for correct partial exits
var float initial_qty = na
var float tp1_qty = na
var float tp2_qty = na
var float current_sl = na  // Dynamic SL that changes after TP1

// Store initial qty on entry (when position opens)
if strategy.position_size != 0 and strategy.position_size[1] == 0
    initial_qty := math.abs(strategy.position_size)
    // Round TP1 qty to avoid tiny remainders (use 6 decimal precision)
    tp1_qty := math.round(initial_qty * (i_tp1_pct / 100) * 1000000) / 1000000
    // TP2 gets EXACTLY the rest - no rounding issues
    tp2_qty := initial_qty - tp1_qty
    tp1_taken := false
    current_sl := active_sl  // Start with original SL

// CRITICAL: Use active_sl as fallback if current_sl not set yet (prevents margin call!)
effective_sl = not na(current_sl) ? current_sl : active_sl

// Detect TP1 fill by comparing current vs previous position
position_was_reduced = math.abs(strategy.position_size) < math.abs(strategy.position_size[1])
position_still_open = strategy.position_size != 0

if position_was_reduced and position_still_open and not tp1_taken
    tp1_taken := true
    if i_move_sl_be and not na(active_entry)
        current_sl := active_entry  // Move SL to breakeven!

// Long Position Management
if strategy.position_size > 0
    // GAP PROTECTION: If price gaps below SL, close immediately at market
    // Uses effective_sl which falls back to active_sl if current_sl not set yet
    if not na(effective_sl) and low < effective_sl
        strategy.close("Long", comment="SL Gap")
    else
        // Always set TP1 for 50% (limit only, no stop)
        strategy.exit("TP1_L", "Long", qty=tp1_qty, limit=active_tp1, comment="TP1")
        // Always set TP2 for remaining 50% (limit only, no stop)
        strategy.exit("TP2_L", "Long", qty=tp2_qty, limit=active_tp2, comment="TP2")
        // Separate SL that updates to BE after TP1 (use effective_sl for safety)
        strategy.exit("SL_L", "Long", stop=effective_sl, comment=tp1_taken ? "BE" : "SL")

// Short Position Management
if strategy.position_size < 0
    // GAP PROTECTION: If price gaps above SL, close immediately at market
    // Uses effective_sl which falls back to active_sl if current_sl not set yet
    if not na(effective_sl) and high > effective_sl
        strategy.close("Short", comment="SL Gap")
    else
        // Always set TP1 for 50% (limit only, no stop)
        strategy.exit("TP1_S", "Short", qty=tp1_qty, limit=active_tp1, comment="TP1")
        // Always set TP2 for remaining 50% (limit only, no stop)
        strategy.exit("TP2_S", "Short", qty=tp2_qty, limit=active_tp2, comment="TP2")
        // Separate SL that updates to BE after TP1 (use effective_sl for safety)
        strategy.exit("SL_S", "Short", stop=effective_sl, comment=tp1_taken ? "BE" : "SL")

// Reset on full position close
if strategy.position_size == 0 and strategy.position_size[1] != 0
    tp1_taken := false
    active_entry := na
    active_sl := na
    active_tp1 := na
    active_tp2 := na
    initial_qty := na
    tp1_qty := na
    tp2_qty := na
    current_sl := na
    active_qty := na
    active_leverage := na
    active_position_value := na
    active_margin := na
    active_sl_loss_pct := na
    active_risk_amount := na

//=============================================================================
// VISUALS - Order Block Boxes with Labels
//=============================================================================

// Draw bullish OBs with price labels
if i_ob_show and barstate.islast
    for i = 0 to math.min(array.size(bull_ob_top) - 1, i_ob_num - 1)
        ob_top = array.get(bull_ob_top, i)
        ob_btm = array.get(bull_ob_btm, i)
        ob_bar = array.get(bull_ob_bar, i)
        ob_age = bar_index - ob_bar

        box.new(ob_bar, ob_top, bar_index + 10, ob_btm,
                border_color=color.new(#089981, 50),
                bgcolor=i_ob_bull_css,
                xloc=xloc.bar_index)

        // Add label with OB details
        label.new(bar_index + 5, ob_top,
                  "Bull OB\nTop: " + str.tostring(ob_top, "#.##") +
                  "\nBtm: " + str.tostring(ob_btm, "#.##") +
                  "\nAge: " + str.tostring(ob_age) + " bars",
                  color=color.new(#089981, 70),
                  textcolor=color.white,
                  style=label.style_label_left,
                  size=size.tiny,
                  xloc=xloc.bar_index)

// Draw bearish OBs with price labels
if i_ob_show and barstate.islast
    for i = 0 to math.min(array.size(bear_ob_top) - 1, i_ob_num - 1)
        ob_top = array.get(bear_ob_top, i)
        ob_btm = array.get(bear_ob_btm, i)
        ob_bar = array.get(bear_ob_bar, i)
        ob_age = bar_index - ob_bar

        box.new(ob_bar, ob_top, bar_index + 10, ob_btm,
                border_color=color.new(#f23645, 50),
                bgcolor=i_ob_bear_css,
                xloc=xloc.bar_index)

        // Add label with OB details
        label.new(bar_index + 5, ob_btm,
                  "Bear OB\nTop: " + str.tostring(ob_top, "#.##") +
                  "\nBtm: " + str.tostring(ob_btm, "#.##") +
                  "\nAge: " + str.tostring(ob_age) + " bars",
                  color=color.new(#f23645, 70),
                  textcolor=color.white,
                  style=label.style_label_left,
                  size=size.tiny,
                  xloc=xloc.bar_index)

//=============================================================================
// PLOTS
//=============================================================================

// MTF Trend Background
bgcolor(i_use_1h_mtf ? (h1_bullish ? color.new(#089981, 95) : h1_bearish ? color.new(#f23645, 95) : na) : na)

// Entry signals
plotshape(long_condition, title="Long Signal", location=location.belowbar, color=#089981, style=shape.triangleup, size=size.small)
plotshape(short_condition, title="Short Signal", location=location.abovebar, color=#f23645, style=shape.triangledown, size=size.small)

// EMAs
plot(ema_fast, "EMA Fast", color=color.new(#2962FF, 50), linewidth=1)
plot(ema_slow, "EMA Slow", color=color.new(#FF6D00, 50), linewidth=1)

// Active Trade Levels (only show when in position)
// Use current_sl which dynamically updates to BE after TP1
plot(strategy.position_size != 0 ? current_sl : na, "Stop Loss", color=tp1_taken ? color.orange : color.red, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 and not tp1_taken ? active_tp1 : na, "TP1", color=color.green, style=plot.style_linebr, linewidth=1)
plot(strategy.position_size != 0 ? active_tp2 : na, "TP2", color=color.lime, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 ? active_entry : na, "Entry", color=color.blue, style=plot.style_linebr, linewidth=1)

//=============================================================================
// INFO TABLE - Shows Margin, Leverage, Position Details (Futures Style)
//=============================================================================
var table infoTable = table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 80), border_width=1)

// Calculate max equity loss (Margin% × SL Loss%)
max_equity_loss_pct = i_margin_pct * i_sl_loss_pct / 100

if barstate.islast
    // Headers
    table.cell(infoTable, 0, 0, "RISK SETTINGS", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, "", text_color=color.white, text_size=size.small)

    // Margin Setting
    table.cell(infoTable, 0, 1, "Margin %", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(i_margin_pct, "#.#") + "% ($" + str.tostring(strategy.equity * i_margin_pct / 100, "#.##") + ")", text_color=color.yellow, text_size=size.small)

    // SL Loss Setting
    table.cell(infoTable, 0, 2, "SL Loss %", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(i_sl_loss_pct, "#") + "% of Position", text_color=color.orange, text_size=size.small)

    // Max Equity Loss (calculated)
    table.cell(infoTable, 0, 3, "Max Loss/Trade", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(max_equity_loss_pct, "#.#") + "% ($" + str.tostring(strategy.equity * max_equity_loss_pct / 100, "#.##") + ")", text_color=color.red, text_size=size.small)

    // Current Position Info (only when in trade)
    if strategy.position_size != 0
        // Separator
        table.cell(infoTable, 0, 4, "ACTIVE TRADE", text_color=color.white, text_size=size.small)
        dir_text = is_long ? "LONG ▲" : "SHORT ▼"
        dir_color = is_long ? color.green : color.red
        table.cell(infoTable, 1, 4, dir_text, text_color=dir_color, text_size=size.small)

        // Entry Price
        table.cell(infoTable, 0, 5, "Entry", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 5, str.tostring(active_entry, "#.####"), text_color=color.blue, text_size=size.small)

        // Stop Loss
        table.cell(infoTable, 0, 6, tp1_taken ? "BE (SL)" : "Stop Loss", text_color=color.gray, text_size=size.small)
        sl_color = tp1_taken ? color.orange : color.red
        table.cell(infoTable, 1, 6, str.tostring(current_sl, "#.####"), text_color=sl_color, text_size=size.small)

        // Actual SL Loss (in $ and % of equity)
        actual_risk = active_qty * math.abs(active_entry - current_sl)
        actual_risk_pct = actual_risk / strategy.equity * 100
        table.cell(infoTable, 0, 7, "SL Hit =", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 7, "-$" + str.tostring(actual_risk, "#.##") + " (-" + str.tostring(actual_risk_pct, "#.#") + "%)", text_color=color.red, text_size=size.small)

        // TP1
        table.cell(infoTable, 0, 8, "TP1 (" + str.tostring(i_tp1_rr, "#.#") + "R)", text_color=color.gray, text_size=size.small)
        tp1_text = tp1_taken ? "FILLED ✓" : str.tostring(active_tp1, "#.####")
        tp1_color = tp1_taken ? color.green : color.lime
        table.cell(infoTable, 1, 8, tp1_text, text_color=tp1_color, text_size=size.small)

        // TP2
        table.cell(infoTable, 0, 9, "TP2 (" + str.tostring(i_tp2_rr, "#.#") + "R)", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 9, str.tostring(active_tp2, "#.####"), text_color=color.lime, text_size=size.small)

        // Margin Used
        table.cell(infoTable, 0, 10, "Margin Used", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 10, "$" + str.tostring(active_margin, "#.##"), text_color=color.yellow, text_size=size.small)

        // Position Value & Leverage
        table.cell(infoTable, 0, 11, "Pos Value", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 11, "$" + str.tostring(active_position_value, "#.##"), text_color=color.white, text_size=size.small)

        table.cell(infoTable, 0, 12, "Leverage", text_color=color.gray, text_size=size.small)
        lev_color = active_leverage > i_max_leverage * 0.8 ? color.red : color.green
        table.cell(infoTable, 1, 12, str.tostring(active_leverage, "#.#") + "x", text_color=lev_color, text_size=size.small)

        // TP1 Status
        table.cell(infoTable, 0, 13, "TP1 Status", text_color=color.gray, text_size=size.small)
        tp1_status = tp1_taken ? "50% CLOSED" : "PENDING"
        table.cell(infoTable, 1, 13, tp1_status, text_color=tp1_taken ? color.green : color.orange, text_size=size.small)
    else
        // Separator
        table.cell(infoTable, 0, 4, "STATUS", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 4, "FLAT", text_color=color.gray, text_size=size.small)

        // Equity
        table.cell(infoTable, 0, 5, "Equity", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 5, "$" + str.tostring(strategy.equity, "#.##"), text_color=color.white, text_size=size.small)

        // Show pending OBs count
        table.cell(infoTable, 0, 6, "Bull OBs", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 6, str.tostring(array.size(bull_ob_top)), text_color=color.green, text_size=size.small)

        table.cell(infoTable, 0, 7, "Bear OBs", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 7, str.tostring(array.size(bear_ob_top)), text_color=color.red, text_size=size.small)

        // Max Leverage Setting
        table.cell(infoTable, 0, 8, "Max Leverage", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 8, str.tostring(i_max_leverage, "#") + "x", text_color=color.white, text_size=size.small)

        // Clear remaining rows
        for row = 9 to 13
            table.cell(infoTable, 0, row, "", text_color=color.gray, text_size=size.small)
            table.cell(infoTable, 1, row, "", text_color=color.gray, text_size=size.small)

//=============================================================================
// ALERTS
//=============================================================================

alertcondition(long_condition, title="Long Entry", message="SMC OB Strategy: Long Entry Signal")
alertcondition(short_condition, title="Short Entry", message="SMC OB Strategy: Short Entry Signal")
alertcondition(bull_break, title="Bullish Structure Break", message="Bullish structure break detected")
alertcondition(bear_break, title="Bearish Structure Break", message="Bearish structure break detected")

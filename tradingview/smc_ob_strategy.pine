// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// SMC Order Block Scalping Strategy - 5min TF optimized
// TP1: 1:1 RR (50%), TP2: 1.5:1 RR (50%), SL moves to BE after TP1
// Dynamic Position Sizing: Risk exactly X% per trade
//@version=6
strategy("SMC OB Scalper v2", overlay=true, default_qty_type=strategy.cash, default_qty_value=100, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.06, calc_on_every_tick=false, process_orders_on_close=true, margin_long=5, margin_short=5)

//=============================================================================
// INPUTS - Risk Management (IMPORTANT!)
//=============================================================================
grp_risk = "Risk Management"
i_risk_pct      = input.float(2.0, "Risk % per Trade", minval=0.5, maxval=10, step=0.5, group=grp_risk, tooltip="Max loss per trade as % of equity. SL hit = this % loss.")
i_max_leverage  = input.float(20.0, "Max Leverage", minval=1, maxval=50, step=1, group=grp_risk, tooltip="Cap leverage to prevent margin calls")
i_direction     = input.string("Both", "Trade Direction", options=["Long", "Short", "Both"], group=grp_risk)

//=============================================================================
// INPUTS - Strategy Settings (Scalping Optimized)
//=============================================================================
grp_strat = "Strategy Settings"
i_sl_buffer     = input.float(0.05, "SL Buffer %", minval=0.0, maxval=1.0, step=0.01, group=grp_strat, tooltip="Buffer below OB for Long SL, above OB for Short SL")
i_max_ob_age    = input.int(20, "Max OB Age (bars)", minval=5, maxval=100, group=grp_strat, tooltip="OBs older than this are ignored")

// Take Profit Settings (Fixed RR)
grp_tp = "Take Profit Settings"
i_tp1_rr        = input.float(1.0, "TP1 Risk:Reward", minval=0.5, maxval=3.0, step=0.1, group=grp_tp, tooltip="TP1 at 1:1 RR")
i_tp1_pct       = input.float(50, "TP1 Position %", minval=10, maxval=90, step=10, group=grp_tp, tooltip="Close 50% at TP1")
i_tp2_rr        = input.float(1.5, "TP2 Risk:Reward", minval=1.0, maxval=5.0, step=0.1, group=grp_tp, tooltip="TP2 at 1.5:1 RR for remaining position")
i_move_sl_be    = input.bool(true, "Move SL to BE after TP1", group=grp_tp)

//=============================================================================
// INPUTS - Order Block Settings
//=============================================================================
grp_ob = "Order Block Settings"
i_ob_show       = input.bool(true, "Show Order Blocks", group=grp_ob)
i_ob_num        = input.int(3, "Max Order Blocks", minval=1, maxval=10, group=grp_ob)
i_ob_strength   = input.float(0.8, "Min OB Strength", minval=0.5, maxval=1.0, step=0.05, group=grp_ob, tooltip="Higher = stronger OBs only")
i_ob_mitigation = input.string("Close", "Mitigation Method", options=["Touch", "Wick", "Close"], group=grp_ob)
i_internal_len  = input.int(5, "Internal Structure Length", minval=2, maxval=20, group=grp_ob)

// OB Colors
i_ob_bull_css   = input.color(color.new(#089981, 80), "Bullish OB Color", group=grp_ob)
i_ob_bear_css   = input.color(color.new(#f23645, 80), "Bearish OB Color", group=grp_ob)

//=============================================================================
// INPUTS - MTF (Multi-Timeframe) Filter
//=============================================================================
grp_mtf = "MTF Trend Filter"
i_use_1h_mtf    = input.bool(true, "Use 1H Trend Filter", group=grp_mtf)
i_use_4h_mtf    = input.bool(false, "Use 4H Trend Filter", group=grp_mtf)
i_use_daily_mtf = input.bool(false, "Use Daily Trend Filter", group=grp_mtf)
i_ema_fast      = input.int(20, "Fast EMA", minval=5, maxval=50, group=grp_mtf)
i_ema_slow      = input.int(50, "Slow EMA", minval=20, maxval=200, group=grp_mtf)

//=============================================================================
// INPUTS - External Indicator Filters (Connect your own indicators!)
//=============================================================================
grp_ext = "External Indicator Filters"
i_use_ext1      = input.bool(false, "Use External Filter 1", group=grp_ext)
i_ext1_source   = input.source(close, "Ext 1 Source", group=grp_ext)
i_ext1_compare  = input.string("Greater Than", "Ext 1 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext1_value    = input.float(0, "Ext 1 Value", group=grp_ext)

i_use_ext2      = input.bool(false, "Use External Filter 2", group=grp_ext)
i_ext2_source   = input.source(close, "Ext 2 Source", group=grp_ext)
i_ext2_compare  = input.string("Greater Than", "Ext 2 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext2_value    = input.float(0, "Ext 2 Value", group=grp_ext)

i_use_ext3      = input.bool(false, "Use External Filter 3", group=grp_ext)
i_ext3_source   = input.source(close, "Ext 3 Source", group=grp_ext)
i_ext3_compare  = input.string("Greater Than", "Ext 3 Condition", options=["Greater Than", "Less Than", "Equals", "Crosses Above", "Crosses Below"], group=grp_ext)
i_ext3_value    = input.float(0, "Ext 3 Value", group=grp_ext)

//=============================================================================
// INPUTS - Time Filter
//=============================================================================
grp_time = "Time Filter"
i_use_time      = input.bool(false, "Use Time Filter", group=grp_time)
i_start_hour    = input.int(8, "Start Hour (UTC)", minval=0, maxval=23, group=grp_time)
i_end_hour      = input.int(20, "End Hour (UTC)", minval=0, maxval=23, group=grp_time)

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

// External condition checker
checkExtCondition(float src, string cond, float val) =>
    result = true
    if cond == "Greater Than"
        result := src > val
    else if cond == "Less Than"
        result := src < val
    else if cond == "Equals"
        result := math.abs(src - val) < 0.0001
    else if cond == "Crosses Above"
        result := ta.crossover(src, val)
    else if cond == "Crosses Below"
        result := ta.crossunder(src, val)
    result

// Check all external filters
checkExternalFilters() =>
    ext1_ok = i_use_ext1 ? checkExtCondition(i_ext1_source, i_ext1_compare, i_ext1_value) : true
    ext2_ok = i_use_ext2 ? checkExtCondition(i_ext2_source, i_ext2_compare, i_ext2_value) : true
    ext3_ok = i_use_ext3 ? checkExtCondition(i_ext3_source, i_ext3_compare, i_ext3_value) : true
    ext1_ok and ext2_ok and ext3_ok

// Time filter
inTradingHours() =>
    if i_use_time
        hour >= i_start_hour and hour < i_end_hour
    else
        true

//=============================================================================
// POSITION SIZE CALCULATION (Risk-Based)
//=============================================================================
// Formula: position_size = (equity * risk%) / (entry - sl)
// This ensures SL hit = exactly risk% loss

calcPositionSize(float entry_price, float sl_price) =>
    // Calculate risk amount in currency
    equity = strategy.equity
    risk_amount = equity * (i_risk_pct / 100)

    // Calculate SL distance in price
    sl_distance = math.abs(entry_price - sl_price)

    // Calculate position size (in units/contracts)
    qty = sl_distance > 0 ? risk_amount / sl_distance : 0

    // Calculate position value and leverage
    position_value = qty * entry_price
    leverage = position_value / equity

    // Cap leverage if too high
    if leverage > i_max_leverage
        qty := (equity * i_max_leverage) / entry_price
        leverage := i_max_leverage

    [qty, leverage, position_value]

// Track calculated values for display
var float active_qty = na
var float active_leverage = na
var float active_position_value = na

//=============================================================================
// MTF TREND DETECTION
//=============================================================================

// Current timeframe EMAs
ema_fast = ta.ema(close, i_ema_fast)
ema_slow = ta.ema(close, i_ema_slow)

// 1H Trend
[h1_close, h1_ema20, h1_ema50] = request.security(syminfo.tickerid, "60", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
h1_bullish = h1_close > h1_ema20 and h1_ema20 > h1_ema50
h1_bearish = h1_close < h1_ema20 and h1_ema20 < h1_ema50

// 4H Trend
[h4_close, h4_ema20, h4_ema50] = request.security(syminfo.tickerid, "240", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
h4_bullish = h4_close > h4_ema20 and h4_ema20 > h4_ema50
h4_bearish = h4_close < h4_ema20 and h4_ema20 < h4_ema50

// Daily Trend
[d_close, d_ema20, d_ema50] = request.security(syminfo.tickerid, "D", [close, ta.ema(close, i_ema_fast), ta.ema(close, i_ema_slow)], lookahead=barmerge.lookahead_off)
d_bullish = d_close > d_ema20 and d_ema20 > d_ema50
d_bearish = d_close < d_ema20 and d_ema20 < d_ema50

// Combined MTF Filter
mtf_long_ok() =>
    h1_ok = i_use_1h_mtf ? h1_bullish : true
    h4_ok = i_use_4h_mtf ? h4_bullish : true
    d_ok  = i_use_daily_mtf ? d_bullish : true
    h1_ok and h4_ok and d_ok

mtf_short_ok() =>
    h1_ok = i_use_1h_mtf ? h1_bearish : true
    h4_ok = i_use_4h_mtf ? h4_bearish : true
    d_ok  = i_use_daily_mtf ? d_bearish : true
    h1_ok and h4_ok and d_ok

//=============================================================================
// ORDER BLOCK DETECTION (Simplified from LuxAlgo)
//=============================================================================

// Swing detection
iH = ta.pivothigh(high, i_internal_len, i_internal_len)
iL = ta.pivotlow(low, i_internal_len, i_internal_len)

// Track internal structure
var int itrend = 0
var float last_swing_high = na
var float last_swing_low = na
var int last_swing_high_bar = na
var int last_swing_low_bar = na

// Update swing points
if not na(iH)
    last_swing_high := high[i_internal_len]
    last_swing_high_bar := bar_index - i_internal_len

if not na(iL)
    last_swing_low := low[i_internal_len]
    last_swing_low_bar := bar_index - i_internal_len

// Detect structure breaks
bull_break = ta.crossover(close, last_swing_high) and not na(last_swing_high)
bear_break = ta.crossunder(close, last_swing_low) and not na(last_swing_low)

// Update trend
if bull_break
    itrend := 1
if bear_break
    itrend := -1

//=============================================================================
// ORDER BLOCK STORAGE
//=============================================================================

// Order Block arrays
var array<float> bull_ob_top = array.new_float(0)
var array<float> bull_ob_btm = array.new_float(0)
var array<int> bull_ob_bar = array.new_int(0)
var array<float> bull_ob_strength = array.new_float(0)

var array<float> bear_ob_top = array.new_float(0)
var array<float> bear_ob_btm = array.new_float(0)
var array<int> bear_ob_bar = array.new_int(0)
var array<float> bear_ob_strength = array.new_float(0)

// Calculate OB strength based on volume and move
calcOBStrength(int lookback) =>
    vol_ratio = volume / ta.sma(volume, 20)
    move_pct = math.abs(close - open) / open * 100
    strength = math.min(1.0, (vol_ratio * 0.5 + move_pct * 0.1))
    strength

// Create bullish OB on structure break
if bull_break and not na(last_swing_low_bar)
    // Find the lowest candle between last swing low and break
    lowest_idx = 0
    lowest_val = low
    for i = 1 to math.min(bar_index - last_swing_low_bar, 50)
        if low[i] < lowest_val
            lowest_val := low[i]
            lowest_idx := i

    ob_top = math.max(open[lowest_idx], close[lowest_idx])
    ob_btm = low[lowest_idx]
    ob_str = calcOBStrength(lowest_idx)

    if ob_str >= i_ob_strength
        array.unshift(bull_ob_top, ob_top)
        array.unshift(bull_ob_btm, ob_btm)
        array.unshift(bull_ob_bar, bar_index - lowest_idx)
        array.unshift(bull_ob_strength, ob_str)

        // Limit array size
        if array.size(bull_ob_top) > i_ob_num
            array.pop(bull_ob_top)
            array.pop(bull_ob_btm)
            array.pop(bull_ob_bar)
            array.pop(bull_ob_strength)

// Create bearish OB on structure break
if bear_break and not na(last_swing_high_bar)
    // Find the highest candle between last swing high and break
    highest_idx = 0
    highest_val = high
    for i = 1 to math.min(bar_index - last_swing_high_bar, 50)
        if high[i] > highest_val
            highest_val := high[i]
            highest_idx := i

    ob_top = high[highest_idx]
    ob_btm = math.min(open[highest_idx], close[highest_idx])
    ob_str = calcOBStrength(highest_idx)

    if ob_str >= i_ob_strength
        array.unshift(bear_ob_top, ob_top)
        array.unshift(bear_ob_btm, ob_btm)
        array.unshift(bear_ob_bar, bar_index - highest_idx)
        array.unshift(bear_ob_strength, ob_str)

        // Limit array size
        if array.size(bear_ob_top) > i_ob_num
            array.pop(bear_ob_top)
            array.pop(bear_ob_btm)
            array.pop(bear_ob_bar)
            array.pop(bear_ob_strength)

//=============================================================================
// ORDER BLOCK MITIGATION & ENTRY SIGNALS
//=============================================================================

// Check for bullish OB entry (price touches bullish OB from above)
var int active_bull_ob_idx = -1
var float bull_entry = na
var float bull_sl = na
var float bull_tp1 = na
var float bull_tp2 = na
var float bull_qty = na

bull_ob_signal = false
if array.size(bull_ob_top) > 0 and strategy.position_size == 0
    for i = 0 to array.size(bull_ob_top) - 1
        ob_top = array.get(bull_ob_top, i)
        ob_btm = array.get(bull_ob_btm, i)
        ob_bar = array.get(bull_ob_bar, i)
        ob_age = bar_index - ob_bar

        // Check if price is touching OB and OB is not too old
        price_in_ob = low <= ob_top and close > ob_btm
        ob_valid = ob_age <= i_max_ob_age

        if price_in_ob and ob_valid and not bull_ob_signal
            // Check mitigation method
            entry_trigger = false
            if i_ob_mitigation == "Touch"
                entry_trigger := low <= ob_top
            else if i_ob_mitigation == "Wick"
                entry_trigger := low <= ob_top and close > ob_top
            else if i_ob_mitigation == "Close"
                entry_trigger := close <= ob_top and close >= ob_btm

            if entry_trigger
                bull_ob_signal := true
                active_bull_ob_idx := i
                bull_entry := close  // Entry at current close
                bull_sl := ob_btm * (1 - i_sl_buffer/100)  // SL below OB + buffer
                sl_dist = bull_entry - bull_sl
                bull_tp1 := bull_entry + (sl_dist * i_tp1_rr)  // TP1 at 1:1
                bull_tp2 := bull_entry + (sl_dist * i_tp2_rr)  // TP2 at 1.5:1

                // Calculate position size based on risk
                [qty, lev, pos_val] = calcPositionSize(bull_entry, bull_sl)
                bull_qty := qty
                break

// Check for bearish OB entry (price touches bearish OB from below)
var int active_bear_ob_idx = -1
var float bear_entry = na
var float bear_sl = na
var float bear_tp1 = na
var float bear_tp2 = na
var float bear_qty = na

bear_ob_signal = false
if array.size(bear_ob_top) > 0 and strategy.position_size == 0
    for i = 0 to array.size(bear_ob_top) - 1
        ob_top = array.get(bear_ob_top, i)
        ob_btm = array.get(bear_ob_btm, i)
        ob_bar = array.get(bear_ob_bar, i)
        ob_age = bar_index - ob_bar

        // Check if price is touching OB and OB is not too old
        price_in_ob = high >= ob_btm and close < ob_top
        ob_valid = ob_age <= i_max_ob_age

        if price_in_ob and ob_valid and not bear_ob_signal
            // Check mitigation method
            entry_trigger = false
            if i_ob_mitigation == "Touch"
                entry_trigger := high >= ob_btm
            else if i_ob_mitigation == "Wick"
                entry_trigger := high >= ob_btm and close < ob_btm
            else if i_ob_mitigation == "Close"
                entry_trigger := close >= ob_btm and close <= ob_top

            if entry_trigger
                bear_ob_signal := true
                active_bear_ob_idx := i
                bear_entry := close  // Entry at current close
                bear_sl := ob_top * (1 + i_sl_buffer/100)  // SL above OB + buffer
                sl_dist = bear_sl - bear_entry
                bear_tp1 := bear_entry - (sl_dist * i_tp1_rr)  // TP1 at 1:1
                bear_tp2 := bear_entry - (sl_dist * i_tp2_rr)  // TP2 at 1.5:1

                // Calculate position size based on risk
                [qty, lev, pos_val] = calcPositionSize(bear_entry, bear_sl)
                bear_qty := qty
                break

//=============================================================================
// ENTRY CONDITIONS
//=============================================================================

// Final long condition
long_condition = bull_ob_signal and
                 (i_direction == "Long" or i_direction == "Both") and
                 mtf_long_ok() and
                 checkExternalFilters() and
                 inTradingHours() and
                 strategy.position_size == 0

// Final short condition
short_condition = bear_ob_signal and
                  (i_direction == "Short" or i_direction == "Both") and
                  mtf_short_ok() and
                  checkExternalFilters() and
                  inTradingHours() and
                  strategy.position_size == 0

//=============================================================================
// STRATEGY EXECUTION
//=============================================================================

// Track position state
var bool tp1_taken = false
var float active_entry = na
var float active_sl = na
var float active_tp1 = na
var float active_tp2 = na
var bool is_long = false

// Entry: Long with calculated position size
if long_condition and bull_qty > 0
    strategy.entry("Long", strategy.long, qty=bull_qty)
    active_entry := bull_entry
    active_sl := bull_sl
    active_tp1 := bull_tp1
    active_tp2 := bull_tp2
    tp1_taken := false
    is_long := true

    // Store for display
    active_qty := bull_qty
    active_leverage := (bull_qty * bull_entry) / strategy.equity
    active_position_value := bull_qty * bull_entry

    // Remove used OB
    if active_bull_ob_idx >= 0 and active_bull_ob_idx < array.size(bull_ob_top)
        array.remove(bull_ob_top, active_bull_ob_idx)
        array.remove(bull_ob_btm, active_bull_ob_idx)
        array.remove(bull_ob_bar, active_bull_ob_idx)
        array.remove(bull_ob_strength, active_bull_ob_idx)

// Entry: Short with calculated position size
if short_condition and bear_qty > 0
    strategy.entry("Short", strategy.short, qty=bear_qty)
    active_entry := bear_entry
    active_sl := bear_sl
    active_tp1 := bear_tp1
    active_tp2 := bear_tp2
    tp1_taken := false
    is_long := false

    // Store for display
    active_qty := bear_qty
    active_leverage := (bear_qty * bear_entry) / strategy.equity
    active_position_value := bear_qty * bear_entry

    // Remove used OB
    if active_bear_ob_idx >= 0 and active_bear_ob_idx < array.size(bear_ob_top)
        array.remove(bear_ob_top, active_bear_ob_idx)
        array.remove(bear_ob_btm, active_bear_ob_idx)
        array.remove(bear_ob_bar, active_bear_ob_idx)
        array.remove(bear_ob_strength, active_bear_ob_idx)

//=============================================================================
// EXIT LOGIC: TP1 (50%) → BE → TP2 (50%)
//=============================================================================

// Track initial position size for correct partial exits
var float initial_qty = na
var float tp1_qty = na
var float tp2_qty = na

// Store initial qty on entry
if strategy.position_size != 0 and strategy.position_size[1] == 0
    initial_qty := math.abs(strategy.position_size)
    tp1_qty := initial_qty * (i_tp1_pct / 100)
    tp2_qty := initial_qty - tp1_qty

// Long Position Management
if strategy.position_size > 0
    current_pos = strategy.position_size

    // TP1 not yet taken
    if not tp1_taken and not na(active_tp1)
        // Set TP1 exit for 50% with SL protection
        strategy.exit("TP1", "Long", qty=tp1_qty, limit=active_tp1, stop=active_sl, comment="TP1")

        // Detect if TP1 was filled (position reduced but not closed)
        if current_pos < initial_qty and current_pos > 0
            tp1_taken := true
            if i_move_sl_be
                active_sl := active_entry  // Move SL to breakeven

    // After TP1: exit remaining with BE stop and TP2
    if tp1_taken and not na(active_tp2)
        strategy.exit("TP2", "Long", limit=active_tp2, stop=active_sl, comment="TP2+BE")

// Short Position Management
if strategy.position_size < 0
    current_pos = math.abs(strategy.position_size)

    // TP1 not yet taken
    if not tp1_taken and not na(active_tp1)
        // Set TP1 exit for 50% with SL protection
        strategy.exit("TP1", "Short", qty=tp1_qty, limit=active_tp1, stop=active_sl, comment="TP1")

        // Detect if TP1 was filled (position reduced but not closed)
        if current_pos < initial_qty and current_pos > 0
            tp1_taken := true
            if i_move_sl_be
                active_sl := active_entry  // Move SL to breakeven

    // After TP1: exit remaining with BE stop and TP2
    if tp1_taken and not na(active_tp2)
        strategy.exit("TP2", "Short", limit=active_tp2, stop=active_sl, comment="TP2+BE")

// Reset on full position close
if strategy.position_size == 0 and strategy.position_size[1] != 0
    tp1_taken := false
    active_entry := na
    active_sl := na
    active_tp1 := na
    active_tp2 := na
    initial_qty := na
    tp1_qty := na
    tp2_qty := na
    active_qty := na
    active_leverage := na
    active_position_value := na

//=============================================================================
// VISUALS - Order Block Boxes
//=============================================================================

// Draw bullish OBs
if i_ob_show and barstate.islast
    for i = 0 to math.min(array.size(bull_ob_top) - 1, i_ob_num - 1)
        ob_top = array.get(bull_ob_top, i)
        ob_btm = array.get(bull_ob_btm, i)
        ob_bar = array.get(bull_ob_bar, i)

        box.new(ob_bar, ob_top, bar_index + 10, ob_btm,
                border_color=color.new(#089981, 50),
                bgcolor=i_ob_bull_css,
                xloc=xloc.bar_index)

// Draw bearish OBs
if i_ob_show and barstate.islast
    for i = 0 to math.min(array.size(bear_ob_top) - 1, i_ob_num - 1)
        ob_top = array.get(bear_ob_top, i)
        ob_btm = array.get(bear_ob_btm, i)
        ob_bar = array.get(bear_ob_bar, i)

        box.new(ob_bar, ob_top, bar_index + 10, ob_btm,
                border_color=color.new(#f23645, 50),
                bgcolor=i_ob_bear_css,
                xloc=xloc.bar_index)

//=============================================================================
// PLOTS
//=============================================================================

// MTF Trend Background
bgcolor(i_use_1h_mtf ? (h1_bullish ? color.new(#089981, 95) : h1_bearish ? color.new(#f23645, 95) : na) : na)

// Entry signals
plotshape(long_condition, title="Long Signal", location=location.belowbar, color=#089981, style=shape.triangleup, size=size.small)
plotshape(short_condition, title="Short Signal", location=location.abovebar, color=#f23645, style=shape.triangledown, size=size.small)

// EMAs
plot(ema_fast, "EMA Fast", color=color.new(#2962FF, 50), linewidth=1)
plot(ema_slow, "EMA Slow", color=color.new(#FF6D00, 50), linewidth=1)

// Active Trade Levels (only show when in position)
plot(strategy.position_size != 0 ? active_sl : na, "Stop Loss", color=color.red, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 and not tp1_taken ? active_tp1 : na, "TP1 (1:1)", color=color.green, style=plot.style_linebr, linewidth=1)
plot(strategy.position_size != 0 ? active_tp2 : na, "TP2 (1.5:1)", color=color.lime, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size != 0 ? active_entry : na, "Entry", color=color.blue, style=plot.style_linebr, linewidth=1)

// Show BE level after TP1
plot(strategy.position_size != 0 and tp1_taken ? active_entry : na, "Breakeven", color=color.orange, style=plot.style_linebr, linewidth=2)

//=============================================================================
// INFO TABLE - Shows Risk, Leverage, Position Details
//=============================================================================
var table infoTable = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast
    // Headers
    table.cell(infoTable, 0, 0, "Parameter", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, "Value", text_color=color.white, text_size=size.small)

    // Risk %
    table.cell(infoTable, 0, 1, "Risk/Trade", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(i_risk_pct, "#.#") + "%", text_color=color.yellow, text_size=size.small)

    // Max Leverage Setting
    table.cell(infoTable, 0, 2, "Max Leverage", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(i_max_leverage, "#.#") + "x", text_color=color.white, text_size=size.small)

    // Current Position Info (only when in trade)
    if strategy.position_size != 0
        // Active Leverage
        table.cell(infoTable, 0, 3, "Active Lev", text_color=color.gray, text_size=size.small)
        lev_color = active_leverage > i_max_leverage * 0.8 ? color.red : color.green
        table.cell(infoTable, 1, 3, str.tostring(active_leverage, "#.##") + "x", text_color=lev_color, text_size=size.small)

        // Position Value
        table.cell(infoTable, 0, 4, "Pos Value", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 4, "$" + str.tostring(active_position_value, "#.##"), text_color=color.white, text_size=size.small)

        // TP1 Status
        table.cell(infoTable, 0, 5, "TP1 Status", text_color=color.gray, text_size=size.small)
        tp1_status = tp1_taken ? "FILLED ✓" : "Pending"
        tp1_color = tp1_taken ? color.green : color.orange
        table.cell(infoTable, 1, 5, tp1_status, text_color=tp1_color, text_size=size.small)
    else
        table.cell(infoTable, 0, 3, "Position", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 3, "FLAT", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 0, 4, "", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 4, "", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 0, 5, "", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 5, "", text_color=color.gray, text_size=size.small)

//=============================================================================
// ALERTS
//=============================================================================

alertcondition(long_condition, title="Long Entry", message="SMC OB Strategy: Long Entry Signal")
alertcondition(short_condition, title="Short Entry", message="SMC OB Strategy: Short Entry Signal")
alertcondition(bull_break, title="Bullish Structure Break", message="Bullish structure break detected")
alertcondition(bear_break, title="Bearish Structure Break", message="Bearish structure break detected")

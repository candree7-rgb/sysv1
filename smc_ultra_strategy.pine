// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © SMC Ultra System - STRATEGY VERSION for Backtesting

//@version=5
strategy("SMC Ultra Strategy", overlay=true, 
         default_qty_type=strategy.percent_of_equity, 
         default_qty_value=100,
         initial_capital=10000,
         commission_type=strategy.commission.percent,
         commission_value=0.075,  // Typical crypto futures fee
         slippage=2,
         pyramiding=0,
         calc_on_every_tick=false)

// ══════════════════════════════════════════════════════════════════════════════
// SETTINGS
// ══════════════════════════════════════════════════════════════════════════════

group_general = "═══ STRATEGY SETTINGS ═══"
minConfidence = input.int(90, "Minimum Confidence %", minval=50, maxval=99, group=group_general)
useTrailingStop = input.bool(true, "Use Trailing Stop", group=group_general)
trailActivation = input.float(50, "Trail Activation % of TP", minval=20, maxval=80, group=group_general)
trailOffset = input.float(30, "Trail Offset % of move", minval=10, maxval=50, group=group_general)
maxTradeDuration = input.int(60, "Max Trade Duration (bars)", minval=10, maxval=200, group=group_general)

group_ob = "═══ ORDER BLOCKS ═══"
obLength = input.int(10, "OB Detection Length", minval=5, maxval=50, group=group_ob)
obMitigationPercent = input.float(0.5, "OB Mitigation %", minval=0.1, maxval=1.0, step=0.1, group=group_ob)

group_atr = "═══ DYNAMIC TARGETS ═══"
atrLength = input.int(14, "ATR Length", minval=5, maxval=50, group=group_atr)
atrMultiplierTP = input.float(1.5, "ATR Multiplier for TP", minval=0.5, maxval=5.0, step=0.1, group=group_atr)
atrMultiplierSL = input.float(1.0, "ATR Multiplier for SL", minval=0.5, maxval=3.0, step=0.1, group=group_atr)

group_mtf = "═══ MULTI-TIMEFRAME ═══"
htfTimeframe = input.timeframe("240", "Higher Timeframe (Bias)", group=group_mtf)
mtfTimeframe = input.timeframe("15", "Medium Timeframe (Setup)", group=group_mtf)

group_filter = "═══ FILTERS ═══"
useVolatilityFilter = input.bool(true, "Use Volatility Filter", group=group_filter)
maxVolatilityRatio = input.float(2.0, "Max Volatility Ratio", minval=1.0, maxval=5.0, group=group_filter)
minVolatilityRatio = input.float(0.5, "Min Volatility Ratio", minval=0.1, maxval=1.0, group=group_filter)

// ══════════════════════════════════════════════════════════════════════════════
// CORE CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════

// ATR
atrValue = ta.atr(atrLength)

// Volatility Regime
atr20 = ta.atr(20)
atrSMA = ta.sma(atr20, 50)
volatilityRatio = atr20 / atrSMA

volatilityOK = not useVolatilityFilter or (volatilityRatio >= minVolatilityRatio and volatilityRatio <= maxVolatilityRatio)

// Swing Detection
swingLen = 5
isSwingHigh(len) => high[len] == ta.highest(high, len * 2 + 1)
isSwingLow(len) => low[len] == ta.lowest(low, len * 2 + 1)

var float lastSwingHigh = na
var float lastSwingLow = na
var bool isBullishStructure = na

if isSwingHigh(swingLen)
    lastSwingHigh := high[swingLen]
if isSwingLow(swingLen)
    lastSwingLow := low[swingLen]

if close > lastSwingHigh and not na(lastSwingHigh)
    isBullishStructure := true
if close < lastSwingLow and not na(lastSwingLow)
    isBullishStructure := false

// ══════════════════════════════════════════════════════════════════════════════
// ORDER BLOCK DETECTION (Simplified for Strategy)
// ══════════════════════════════════════════════════════════════════════════════

// Bullish OB: Last bearish candle before strong bullish move
detectBullishOB() =>
    impulseUp = close > open and (close - open) > atrValue * 1.5
    bool foundOB = false
    float obTop = na
    float obBottom = na
    
    if impulseUp
        for i = 1 to obLength
            if close[i] < open[i]
                obTop := high[i]
                obBottom := low[i]
                foundOB := true
                break
    [foundOB, obTop, obBottom]

detectBearishOB() =>
    impulseDown = close < open and (open - close) > atrValue * 1.5
    bool foundOB = false
    float obTop = na
    float obBottom = na
    
    if impulseDown
        for i = 1 to obLength
            if close[i] > open[i]
                obTop := high[i]
                obBottom := low[i]
                foundOB := true
                break
    [foundOB, obTop, obBottom]

[hasBullOB, bullOBTop, bullOBBottom] = detectBullishOB()
[hasBearOB, bearOBTop, bearOBBottom] = detectBearishOB()

// Track active OBs
var float activeBullOBTop = na
var float activeBullOBBottom = na
var float activeBearOBTop = na
var float activeBearOBBottom = na
var int bullOBBar = na
var int bearOBBar = na

if hasBullOB
    activeBullOBTop := bullOBTop
    activeBullOBBottom := bullOBBottom
    bullOBBar := bar_index

if hasBearOB
    activeBearOBTop := bearOBTop
    activeBearOBBottom := bearOBBottom
    bearOBBar := bar_index

// Check if price is at OB
nearBullOB = not na(activeBullOBTop) and low <= activeBullOBTop * 1.002 and low >= activeBullOBBottom * 0.998 and (bar_index - bullOBBar) < 50
nearBearOB = not na(activeBearOBTop) and high >= activeBearOBBottom * 0.998 and high <= activeBearOBTop * 1.002 and (bar_index - bearOBBar) < 50

// Mitigate OBs
if not na(activeBullOBBottom) and low < activeBullOBBottom
    activeBullOBTop := na
    activeBullOBBottom := na

if not na(activeBearOBTop) and high > activeBearOBTop
    activeBearOBTop := na
    activeBearOBBottom := na

// ══════════════════════════════════════════════════════════════════════════════
// FAIR VALUE GAP DETECTION
// ══════════════════════════════════════════════════════════════════════════════

bullFVG = low > high[2]
bearFVG = high < low[2]

var float activeBullFVGTop = na
var float activeBullFVGBottom = na
var float activeBearFVGTop = na
var float activeBearFVGBottom = na

if bullFVG
    activeBullFVGTop := low
    activeBullFVGBottom := high[2]

if bearFVG
    activeBearFVGTop := low[2]
    activeBearFVGBottom := high

// Check if in FVG
inBullFVG = not na(activeBullFVGTop) and low <= activeBullFVGTop and low >= activeBullFVGBottom
inBearFVG = not na(activeBearFVGTop) and high >= activeBearFVGBottom and high <= activeBearFVGTop

// Fill FVGs
if not na(activeBullFVGBottom) and low < activeBullFVGBottom
    activeBullFVGTop := na
    activeBullFVGBottom := na

if not na(activeBearFVGTop) and high > activeBearFVGTop
    activeBearFVGTop := na
    activeBearFVGBottom := na

// ══════════════════════════════════════════════════════════════════════════════
// LIQUIDITY SWEEP DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Recent swing points
recentSwingHigh = ta.highest(high, 20)[1]
recentSwingLow = ta.lowest(low, 20)[1]

// Sweep and reversal
bullishSweep = low < recentSwingLow and close > recentSwingLow and close > open
bearishSweep = high > recentSwingHigh and close < recentSwingHigh and close < open

// ══════════════════════════════════════════════════════════════════════════════
// MULTI-TIMEFRAME ANALYSIS
// ══════════════════════════════════════════════════════════════════════════════

htfClose = request.security(syminfo.tickerid, htfTimeframe, close)
htfEMA20 = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, 20))
htfEMA50 = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, 50))

htfBullish = htfClose > htfEMA20 and htfEMA20 > htfEMA50
htfBearish = htfClose < htfEMA20 and htfEMA20 < htfEMA50
htfNeutral = not htfBullish and not htfBearish

mtfRSI = request.security(syminfo.tickerid, mtfTimeframe, ta.rsi(close, 14))
mtfOversold = mtfRSI < 30
mtfOverbought = mtfRSI > 70

// ══════════════════════════════════════════════════════════════════════════════
// CONFLUENCE SCORING
// ══════════════════════════════════════════════════════════════════════════════

calcBullishScore() =>
    float score = 0
    
    if htfBullish
        score += 25
    else if htfNeutral
        score += 10
    
    if bullishSweep
        score += 20
    
    if nearBullOB
        score += 20
    
    if inBullFVG
        score += 15
    
    if mtfOversold
        score += 10
    
    if isBullishStructure
        score += 10
    
    math.min(score, 100)

calcBearishScore() =>
    float score = 0
    
    if htfBearish
        score += 25
    else if htfNeutral
        score += 10
    
    if bearishSweep
        score += 20
    
    if nearBearOB
        score += 20
    
    if inBearFVG
        score += 15
    
    if mtfOverbought
        score += 10
    
    if not isBullishStructure and not na(isBullishStructure)
        score += 10
    
    math.min(score, 100)

bullScore = calcBullishScore()
bearScore = calcBearishScore()

// ══════════════════════════════════════════════════════════════════════════════
// TRADE MANAGEMENT VARIABLES
// ══════════════════════════════════════════════════════════════════════════════

var int entryBar = na
var float entryPrice = na
var float takeProfit = na
var float stopLoss = na
var bool trailActivated = false

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY CONDITIONS
// ══════════════════════════════════════════════════════════════════════════════

longCondition = bullScore >= minConfidence and close > open and volatilityOK and strategy.position_size == 0
shortCondition = bearScore >= minConfidence and close < open and volatilityOK and strategy.position_size == 0

// Calculate dynamic TP/SL
targetMove = atrValue * atrMultiplierTP
stopMove = atrValue * atrMultiplierSL

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY EXECUTION
// ══════════════════════════════════════════════════════════════════════════════

if longCondition
    entryPrice := close
    takeProfit := close + targetMove
    stopLoss := close - stopMove
    entryBar := bar_index
    trailActivated := false
    
    strategy.entry("Long", strategy.long)
    strategy.exit("Long Exit", "Long", limit=takeProfit, stop=stopLoss)

if shortCondition
    entryPrice := close
    takeProfit := close - targetMove
    stopLoss := close + stopMove
    entryBar := bar_index
    trailActivated := false
    
    strategy.entry("Short", strategy.short)
    strategy.exit("Short Exit", "Short", limit=takeProfit, stop=stopLoss)

// ══════════════════════════════════════════════════════════════════════════════
// TRADE MANAGEMENT (Trailing & Time-based exit)
// ══════════════════════════════════════════════════════════════════════════════

if strategy.position_size > 0  // Long position
    currentProfit = (close - entryPrice) / entryPrice * 100
    targetProfit = (takeProfit - entryPrice) / entryPrice * 100
    profitPercent = currentProfit / targetProfit * 100
    
    // Activate trailing stop
    if useTrailingStop and profitPercent >= trailActivation and not trailActivated
        trailActivated := true
        newSL = entryPrice + (close - entryPrice) * (1 - trailOffset / 100)
        strategy.exit("Long Trail", "Long", limit=takeProfit, stop=newSL)
    
    // Update trailing stop
    if trailActivated
        newSL = math.max(stopLoss, entryPrice + (close - entryPrice) * (1 - trailOffset / 100))
        if newSL > stopLoss
            stopLoss := newSL
            strategy.exit("Long Trail", "Long", limit=takeProfit, stop=newSL)
    
    // Time-based exit
    if (bar_index - entryBar) >= maxTradeDuration
        strategy.close("Long", comment="Time Exit")

if strategy.position_size < 0  // Short position
    currentProfit = (entryPrice - close) / entryPrice * 100
    targetProfit = (entryPrice - takeProfit) / entryPrice * 100
    profitPercent = currentProfit / targetProfit * 100
    
    // Activate trailing stop
    if useTrailingStop and profitPercent >= trailActivation and not trailActivated
        trailActivated := true
        newSL = entryPrice - (entryPrice - close) * (1 - trailOffset / 100)
        strategy.exit("Short Trail", "Short", limit=takeProfit, stop=newSL)
    
    // Update trailing stop
    if trailActivated
        newSL = math.min(stopLoss, entryPrice - (entryPrice - close) * (1 - trailOffset / 100))
        if newSL < stopLoss
            stopLoss := newSL
            strategy.exit("Short Trail", "Short", limit=takeProfit, stop=newSL)
    
    // Time-based exit
    if (bar_index - entryBar) >= maxTradeDuration
        strategy.close("Short", comment="Time Exit")

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL ELEMENTS
// ══════════════════════════════════════════════════════════════════════════════

// Plot entry signals
plotshape(longCondition, title="Long", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)
plotshape(shortCondition, title="Short", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)

// Background color for active trade
bgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : strategy.position_size < 0 ? color.new(color.red, 95) : na)

// Score plots (for debugging)
plot(bullScore, title="Bull Score", color=color.green, display=display.data_window)
plot(bearScore, title="Bear Score", color=color.red, display=display.data_window)
plot(volatilityRatio, title="Volatility Ratio", color=color.blue, display=display.data_window)

// ══════════════════════════════════════════════════════════════════════════════
// DASHBOARD
// ══════════════════════════════════════════════════════════════════════════════

var table statsTable = table.new(position.bottom_right, 2, 8, bgcolor=color.new(color.black, 80))

if barstate.islast
    // Calculate stats
    winRate = strategy.wintrades / math.max(strategy.closedtrades, 1) * 100
    avgWin = strategy.grossprofit / math.max(strategy.wintrades, 1)
    avgLoss = math.abs(strategy.grossloss) / math.max(strategy.losstrades, 1)
    profitFactor = strategy.grossprofit / math.max(math.abs(strategy.grossloss), 1)
    
    table.cell(statsTable, 0, 0, "PERFORMANCE", bgcolor=color.new(color.blue, 70), text_color=color.white)
    table.cell(statsTable, 1, 0, "", bgcolor=color.new(color.blue, 70))
    
    table.cell(statsTable, 0, 1, "Total Trades", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 1, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 2, "Win Rate", text_color=color.white, text_size=size.small)
    wrColor = winRate >= 65 ? color.green : winRate >= 55 ? color.yellow : color.red
    table.cell(statsTable, 1, 2, str.tostring(winRate, "#.#") + "%", bgcolor=wrColor, text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 3, "Profit Factor", text_color=color.white, text_size=size.small)
    pfColor = profitFactor >= 2 ? color.green : profitFactor >= 1.5 ? color.yellow : color.red
    table.cell(statsTable, 1, 3, str.tostring(profitFactor, "#.##"), bgcolor=pfColor, text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 4, "Avg Win", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 4, "$" + str.tostring(avgWin, "#.##"), text_color=color.green, text_size=size.small)
    
    table.cell(statsTable, 0, 5, "Avg Loss", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 5, "$" + str.tostring(avgLoss, "#.##"), text_color=color.red, text_size=size.small)
    
    table.cell(statsTable, 0, 6, "Net Profit", text_color=color.white, text_size=size.small)
    npColor = strategy.netprofit > 0 ? color.green : color.red
    table.cell(statsTable, 1, 6, "$" + str.tostring(strategy.netprofit, "#.##"), bgcolor=npColor, text_color=color.white, text_size=size.small)
    
    table.cell(statsTable, 0, 7, "Max DD", text_color=color.white, text_size=size.small)
    table.cell(statsTable, 1, 7, str.tostring(strategy.max_drawdown / strategy.initial_capital * 100, "#.#") + "%", text_color=color.red, text_size=size.small)

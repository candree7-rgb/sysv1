// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Ultra SMC Trading System v1.0
// Designed for high-probability entries with dynamic targets

//@version=5
indicator("SMC Ultra System", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ══════════════════════════════════════════════════════════════════════════════
// SETTINGS
// ══════════════════════════════════════════════════════════════════════════════

// General Settings
group_general = "═══ GENERAL SETTINGS ═══"
showDashboard = input.bool(true, "Show Dashboard", group=group_general)
minConfidence = input.int(90, "Minimum Confidence %", minval=50, maxval=99, group=group_general)

// Order Block Settings
group_ob = "═══ ORDER BLOCKS ═══"
obLength = input.int(10, "OB Detection Length", minval=5, maxval=50, group=group_ob)
obMitigationPercent = input.float(0.5, "OB Mitigation %", minval=0.1, maxval=1.0, step=0.1, group=group_ob)
showOB = input.bool(true, "Show Order Blocks", group=group_ob)
obBullColor = input.color(color.new(color.green, 80), "Bullish OB Color", group=group_ob)
obBearColor = input.color(color.new(color.red, 80), "Bearish OB Color", group=group_ob)

// Fair Value Gap Settings
group_fvg = "═══ FAIR VALUE GAPS ═══"
showFVG = input.bool(true, "Show FVGs", group=group_fvg)
fvgMinSize = input.float(0.1, "Min FVG Size %", minval=0.01, maxval=1.0, step=0.01, group=group_fvg)
fvgBullColor = input.color(color.new(color.teal, 85), "Bullish FVG Color", group=group_fvg)
fvgBearColor = input.color(color.new(color.maroon, 85), "Bearish FVG Color", group=group_fvg)

// Liquidity Settings
group_liq = "═══ LIQUIDITY ═══"
showLiquidity = input.bool(true, "Show Liquidity Levels", group=group_liq)
liqLookback = input.int(50, "Liquidity Lookback", minval=20, maxval=200, group=group_liq)
liqColor = input.color(color.new(color.orange, 50), "Liquidity Color", group=group_liq)

// ATR & Dynamic Targets
group_atr = "═══ DYNAMIC TARGETS ═══"
atrLength = input.int(14, "ATR Length", minval=5, maxval=50, group=group_atr)
atrMultiplierTP = input.float(1.5, "ATR Multiplier for TP", minval=0.5, maxval=5.0, step=0.1, group=group_atr)
atrMultiplierSL = input.float(1.0, "ATR Multiplier for SL", minval=0.5, maxval=3.0, step=0.1, group=group_atr)
maxLeverage = input.int(50, "Max Leverage", minval=5, maxval=100, group=group_atr)
targetProfitPercent = input.float(10.0, "Target Profit % (after leverage)", minval=1.0, maxval=50.0, group=group_atr)

// Multi-Timeframe Settings
group_mtf = "═══ MULTI-TIMEFRAME ═══"
htfTimeframe = input.timeframe("240", "Higher Timeframe (Bias)", group=group_mtf)
mtfTimeframe = input.timeframe("15", "Medium Timeframe (Setup)", group=group_mtf)

// ══════════════════════════════════════════════════════════════════════════════
// TYPES & VARIABLES
// ══════════════════════════════════════════════════════════════════════════════

// Order Block Type
type OrderBlock
    float top
    float bottom
    int startBar
    bool isBullish
    bool isMitigated
    box boxId

// Fair Value Gap Type
type FVG
    float top
    float bottom
    int startBar
    bool isBullish
    bool isFilled
    box boxId

// Arrays for storage
var OrderBlock[] bullishOBs = array.new<OrderBlock>()
var OrderBlock[] bearishOBs = array.new<OrderBlock>()
var FVG[] bullishFVGs = array.new<FVG>()
var FVG[] bearishFVGs = array.new<FVG>()
var line[] liquidityLines = array.new<line>()

// ══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ══════════════════════════════════════════════════════════════════════════════

// Calculate ATR
atrValue = ta.atr(atrLength)

// Swing High/Low Detection
isSwingHigh(len) =>
    high[len] == ta.highest(high, len * 2 + 1)

isSwingLow(len) =>
    low[len] == ta.lowest(low, len * 2 + 1)

// Market Structure Detection
var float lastSwingHigh = na
var float lastSwingLow = na
var bool isBullishStructure = na

// Update swing points
swingLen = 5
if isSwingHigh(swingLen)
    lastSwingHigh := high[swingLen]
if isSwingLow(swingLen)
    lastSwingLow := low[swingLen]

// Determine structure
bullishMSS = close > lastSwingHigh and not na(lastSwingHigh)
bearishMSS = close < lastSwingLow and not na(lastSwingLow)

if bullishMSS
    isBullishStructure := true
if bearishMSS
    isBullishStructure := false

// ══════════════════════════════════════════════════════════════════════════════
// ORDER BLOCK DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Detect Bullish Order Block (last red candle before impulse up)
detectBullishOB() =>
    bool detected = false
    float obTop = na
    float obBottom = na
    
    // Look for strong bullish impulse
    impulseUp = close > open and (close - open) > atrValue * 1.5
    
    if impulseUp
        // Find last bearish candle before impulse
        for i = 1 to obLength
            if close[i] < open[i]  // Bearish candle
                obTop := high[i]
                obBottom := low[i]
                detected := true
                break
    
    [detected, obTop, obBottom]

// Detect Bearish Order Block (last green candle before impulse down)
detectBearishOB() =>
    bool detected = false
    float obTop = na
    float obBottom = na
    
    // Look for strong bearish impulse
    impulseDown = close < open and (open - close) > atrValue * 1.5
    
    if impulseDown
        // Find last bullish candle before impulse
        for i = 1 to obLength
            if close[i] > open[i]  // Bullish candle
                obTop := high[i]
                obBottom := low[i]
                detected := true
                break
    
    [detected, obTop, obBottom]

// Process Bullish OB
[bullOBDetected, bullOBTop, bullOBBottom] = detectBullishOB()

if bullOBDetected and showOB
    newOB = OrderBlock.new()
    newOB.top := bullOBTop
    newOB.bottom := bullOBBottom
    newOB.startBar := bar_index
    newOB.isBullish := true
    newOB.isMitigated := false
    newOB.boxId := box.new(bar_index - obLength, bullOBTop, bar_index + 50, bullOBBottom, 
                           border_color=color.green, bgcolor=obBullColor, border_width=1)
    array.push(bullishOBs, newOB)

// Process Bearish OB
[bearOBDetected, bearOBTop, bearOBBottom] = detectBearishOB()

if bearOBDetected and showOB
    newOB = OrderBlock.new()
    newOB.top := bearOBTop
    newOB.bottom := bearOBBottom
    newOB.startBar := bar_index
    newOB.isBullish := false
    newOB.isMitigated := false
    newOB.boxId := box.new(bar_index - obLength, bearOBTop, bar_index + 50, bearOBBottom, 
                           border_color=color.red, bgcolor=obBearColor, border_width=1)
    array.push(bearishOBs, newOB)

// Check OB Mitigation
checkOBMitigation() =>
    // Check bullish OBs
    if array.size(bullishOBs) > 0
        for i = array.size(bullishOBs) - 1 to 0
            ob = array.get(bullishOBs, i)
            if not ob.isMitigated
                mitigationLevel = ob.bottom + (ob.top - ob.bottom) * obMitigationPercent
                if low <= mitigationLevel
                    ob.isMitigated := true
                    box.set_bgcolor(ob.boxId, color.new(color.gray, 90))
    
    // Check bearish OBs
    if array.size(bearishOBs) > 0
        for i = array.size(bearishOBs) - 1 to 0
            ob = array.get(bearishOBs, i)
            if not ob.isMitigated
                mitigationLevel = ob.top - (ob.top - ob.bottom) * obMitigationPercent
                if high >= mitigationLevel
                    ob.isMitigated := true
                    box.set_bgcolor(ob.boxId, color.new(color.gray, 90))

checkOBMitigation()

// ══════════════════════════════════════════════════════════════════════════════
// FAIR VALUE GAP DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Bullish FVG: Gap between candle 1's high and candle 3's low (with candle 2 in between)
bullFVGCondition = low > high[2] and (low - high[2]) / close * 100 > fvgMinSize
bearFVGCondition = high < low[2] and (low[2] - high) / close * 100 > fvgMinSize

if bullFVGCondition and showFVG
    newFVG = FVG.new()
    newFVG.top := low
    newFVG.bottom := high[2]
    newFVG.startBar := bar_index - 1
    newFVG.isBullish := true
    newFVG.isFilled := false
    newFVG.boxId := box.new(bar_index - 2, low, bar_index + 30, high[2], 
                            border_color=color.teal, bgcolor=fvgBullColor, border_width=1, border_style=line.style_dashed)
    array.push(bullishFVGs, newFVG)

if bearFVGCondition and showFVG
    newFVG = FVG.new()
    newFVG.top := low[2]
    newFVG.bottom := high
    newFVG.startBar := bar_index - 1
    newFVG.isBullish := false
    newFVG.isFilled := false
    newFVG.boxId := box.new(bar_index - 2, low[2], bar_index + 30, high, 
                            border_color=color.maroon, bgcolor=fvgBearColor, border_width=1, border_style=line.style_dashed)
    array.push(bearishFVGs, newFVG)

// Check FVG Fill
checkFVGFill() =>
    // Bullish FVGs filled when price drops into them
    if array.size(bullishFVGs) > 0
        for i = array.size(bullishFVGs) - 1 to 0
            fvg = array.get(bullishFVGs, i)
            if not fvg.isFilled and low <= fvg.top
                fvg.isFilled := true
                box.set_bgcolor(fvg.boxId, color.new(color.gray, 95))
    
    // Bearish FVGs filled when price rises into them
    if array.size(bearishFVGs) > 0
        for i = array.size(bearishFVGs) - 1 to 0
            fvg = array.get(bearishFVGs, i)
            if not fvg.isFilled and high >= fvg.bottom
                fvg.isFilled := true
                box.set_bgcolor(fvg.boxId, color.new(color.gray, 95))

checkFVGFill()

// ══════════════════════════════════════════════════════════════════════════════
// LIQUIDITY DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Find swing highs and lows as liquidity levels
var float[] swingHighs = array.new_float()
var float[] swingLows = array.new_float()
var int[] swingHighBars = array.new_int()
var int[] swingLowBars = array.new_int()

if isSwingHigh(3) and showLiquidity
    array.push(swingHighs, high[3])
    array.push(swingHighBars, bar_index - 3)
    // Limit array size
    if array.size(swingHighs) > 20
        array.shift(swingHighs)
        array.shift(swingHighBars)

if isSwingLow(3) and showLiquidity
    array.push(swingLows, low[3])
    array.push(swingLowBars, bar_index - 3)
    if array.size(swingLows) > 20
        array.shift(swingLows)
        array.shift(swingLowBars)

// Detect Liquidity Sweep
var bool bullishSweep = false
var bool bearishSweep = false

// Check if we swept a low and reversed (bullish sweep)
if array.size(swingLows) > 0
    for i = 0 to array.size(swingLows) - 1
        lvl = array.get(swingLows, i)
        if low < lvl and close > lvl and close > open
            bullishSweep := true
            break

// Check if we swept a high and reversed (bearish sweep)
if array.size(swingHighs) > 0
    for i = 0 to array.size(swingHighs) - 1
        lvl = array.get(swingHighs, i)
        if high > lvl and close < lvl and close < open
            bearishSweep := true
            break

// ══════════════════════════════════════════════════════════════════════════════
// MULTI-TIMEFRAME ANALYSIS
// ══════════════════════════════════════════════════════════════════════════════

// Higher Timeframe Bias
htfClose = request.security(syminfo.tickerid, htfTimeframe, close)
htfOpen = request.security(syminfo.tickerid, htfTimeframe, open)
htfHigh = request.security(syminfo.tickerid, htfTimeframe, high)
htfLow = request.security(syminfo.tickerid, htfTimeframe, low)
htfEMA20 = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, 20))
htfEMA50 = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, 50))

htfBullish = htfClose > htfEMA20 and htfEMA20 > htfEMA50
htfBearish = htfClose < htfEMA20 and htfEMA20 < htfEMA50
htfNeutral = not htfBullish and not htfBearish

// Medium Timeframe Confirmation
mtfClose = request.security(syminfo.tickerid, mtfTimeframe, close)
mtfHigh = request.security(syminfo.tickerid, mtfTimeframe, high)
mtfLow = request.security(syminfo.tickerid, mtfTimeframe, low)
mtfRSI = request.security(syminfo.tickerid, mtfTimeframe, ta.rsi(close, 14))

mtfOversold = mtfRSI < 30
mtfOverbought = mtfRSI > 70

// ══════════════════════════════════════════════════════════════════════════════
// VOLATILITY & REGIME DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Current volatility vs average
atr20 = ta.atr(20)
atrSMA = ta.sma(atr20, 50)
volatilityRatio = atr20 / atrSMA

// Regime Classification
isHighVolatility = volatilityRatio > 1.5
isLowVolatility = volatilityRatio < 0.7
isNormalVolatility = not isHighVolatility and not isLowVolatility

// Trend Strength (ADX)
[diPlus, diMinus, adxValue] = ta.dmi(14, 14)
isTrending = adxValue > 25
isRanging = adxValue < 20

// ══════════════════════════════════════════════════════════════════════════════
// CONFLUENCE SCORING
// ══════════════════════════════════════════════════════════════════════════════

// Check for active (unmitigated) Order Blocks near price
nearBullishOB() =>
    bool result = false
    if array.size(bullishOBs) > 0
        for i = array.size(bullishOBs) - 1 to math.max(0, array.size(bullishOBs) - 10)
            ob = array.get(bullishOBs, i)
            if not ob.isMitigated
                // Price is within or just above OB
                if low <= ob.top * 1.002 and low >= ob.bottom * 0.998
                    result := true
                    break
    result

nearBearishOB() =>
    bool result = false
    if array.size(bearishOBs) > 0
        for i = array.size(bearishOBs) - 1 to math.max(0, array.size(bearishOBs) - 10)
            ob = array.get(bearishOBs, i)
            if not ob.isMitigated
                if high >= ob.bottom * 0.998 and high <= ob.top * 1.002
                    result := true
                    break
    result

// Check for unfilled FVGs near price
nearBullishFVG() =>
    bool result = false
    if array.size(bullishFVGs) > 0
        for i = array.size(bullishFVGs) - 1 to math.max(0, array.size(bullishFVGs) - 10)
            fvg = array.get(bullishFVGs, i)
            if not fvg.isFilled
                if low <= fvg.top * 1.001 and low >= fvg.bottom * 0.999
                    result := true
                    break
    result

nearBearishFVG() =>
    bool result = false
    if array.size(bearishFVGs) > 0
        for i = array.size(bearishFVGs) - 1 to math.max(0, array.size(bearishFVGs) - 10)
            fvg = array.get(bearishFVGs, i)
            if not fvg.isFilled
                if high >= fvg.bottom * 0.999 and high <= fvg.top * 1.001
                    result := true
                    break
    result

// Calculate Confluence Scores
calcBullishScore() =>
    float score = 0
    
    // HTF Alignment (+25)
    if htfBullish
        score += 25
    else if htfNeutral
        score += 10
    
    // Liquidity Sweep (+20)
    if bullishSweep
        score += 20
    
    // Near Bullish OB (+20)
    if nearBullishOB()
        score += 20
    
    // Near Bullish FVG (+15)
    if nearBullishFVG()
        score += 15
    
    // MTF Oversold (+10)
    if mtfOversold
        score += 10
    
    // Market Structure Bullish (+10)
    if isBullishStructure
        score += 10
    
    // Volatility bonus (normal = best)
    if isNormalVolatility
        score += 5
    else if isHighVolatility
        score -= 10
    
    math.min(score, 100)

calcBearishScore() =>
    float score = 0
    
    // HTF Alignment (+25)
    if htfBearish
        score += 25
    else if htfNeutral
        score += 10
    
    // Liquidity Sweep (+20)
    if bearishSweep
        score += 20
    
    // Near Bearish OB (+20)
    if nearBearishOB()
        score += 20
    
    // Near Bearish FVG (+15)
    if nearBearishFVG()
        score += 15
    
    // MTF Overbought (+10)
    if mtfOverbought
        score += 10
    
    // Market Structure Bearish (+10)
    if not isBullishStructure and not na(isBullishStructure)
        score += 10
    
    // Volatility bonus
    if isNormalVolatility
        score += 5
    else if isHighVolatility
        score -= 10
    
    math.min(score, 100)

bullishScore = calcBullishScore()
bearishScore = calcBearishScore()

// ══════════════════════════════════════════════════════════════════════════════
// DYNAMIC TARGET CALCULATION
// ══════════════════════════════════════════════════════════════════════════════

// Calculate targets based on ATR
targetMove = atrValue * atrMultiplierTP
stopMove = atrValue * atrMultiplierSL

// Calculate required leverage for target profit
targetMovePercent = (targetMove / close) * 100
requiredLeverage = math.min(targetProfitPercent / targetMovePercent, maxLeverage)

// Round leverage to practical values
practicalLeverage = requiredLeverage <= 10 ? math.round(requiredLeverage) : 
                   requiredLeverage <= 25 ? math.round(requiredLeverage / 5) * 5 :
                   math.round(requiredLeverage / 10) * 10

// ══════════════════════════════════════════════════════════════════════════════
// SIGNAL GENERATION
// ══════════════════════════════════════════════════════════════════════════════

// Entry Conditions
longCondition = bullishScore >= minConfidence and close > open
shortCondition = bearishScore >= minConfidence and close < open

// Calculate entry, TP, SL levels
longEntry = close
longTP = close + targetMove
longSL = close - stopMove

shortEntry = close
shortTP = close - targetMove
shortSL = close + stopMove

// Plot Signals
plotshape(longCondition, title="Long Signal", location=location.belowbar, 
          color=color.green, style=shape.triangleup, size=size.normal, 
          text="LONG", textcolor=color.white)

plotshape(shortCondition, title="Short Signal", location=location.abovebar, 
          color=color.red, style=shape.triangledown, size=size.normal, 
          text="SHORT", textcolor=color.white)

// Draw TP/SL lines on signal
if longCondition
    line.new(bar_index, longTP, bar_index + 20, longTP, color=color.green, style=line.style_dashed, width=1)
    line.new(bar_index, longSL, bar_index + 20, longSL, color=color.red, style=line.style_dashed, width=1)
    label.new(bar_index + 10, longTP, "TP: " + str.tostring(longTP, "#.####"), color=color.green, textcolor=color.white, size=size.tiny)
    label.new(bar_index + 10, longSL, "SL: " + str.tostring(longSL, "#.####"), color=color.red, textcolor=color.white, size=size.tiny)

if shortCondition
    line.new(bar_index, shortTP, bar_index + 20, shortTP, color=color.green, style=line.style_dashed, width=1)
    line.new(bar_index, shortSL, bar_index + 20, shortSL, color=color.red, style=line.style_dashed, width=1)
    label.new(bar_index + 10, shortTP, "TP: " + str.tostring(shortTP, "#.####"), color=color.green, textcolor=color.white, size=size.tiny)
    label.new(bar_index + 10, shortSL, "SL: " + str.tostring(shortSL, "#.####"), color=color.red, textcolor=color.white, size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// DASHBOARD
// ══════════════════════════════════════════════════════════════════════════════

if showDashboard
    var table dashboard = table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 80), border_width=1)
    
    // Header
    table.cell(dashboard, 0, 0, "SMC ULTRA SYSTEM", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.normal)
    table.cell(dashboard, 1, 0, "v1.0", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.normal)
    
    // HTF Bias
    htfBiasText = htfBullish ? "BULLISH" : htfBearish ? "BEARISH" : "NEUTRAL"
    htfBiasColor = htfBullish ? color.green : htfBearish ? color.red : color.gray
    table.cell(dashboard, 0, 1, "HTF Bias", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 1, htfBiasText, bgcolor=htfBiasColor, text_color=color.white, text_size=size.small)
    
    // Market Regime
    regimeText = isTrending ? "TRENDING" : isRanging ? "RANGING" : "TRANSITIONING"
    regimeColor = isTrending ? color.blue : isRanging ? color.purple : color.gray
    table.cell(dashboard, 0, 2, "Regime", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 2, regimeText, bgcolor=regimeColor, text_color=color.white, text_size=size.small)
    
    // Volatility
    volaText = isHighVolatility ? "HIGH" : isLowVolatility ? "LOW" : "NORMAL"
    volaColor = isHighVolatility ? color.red : isLowVolatility ? color.yellow : color.green
    table.cell(dashboard, 0, 3, "Volatility", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 3, volaText, bgcolor=volaColor, text_color=color.white, text_size=size.small)
    
    // Scores
    table.cell(dashboard, 0, 4, "─── SCORES ───", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 4, "", text_color=color.gray, text_size=size.tiny)
    
    bullScoreColor = bullishScore >= 90 ? color.green : bullishScore >= 70 ? color.yellow : color.gray
    table.cell(dashboard, 0, 5, "Bull Score", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 5, str.tostring(bullishScore, "#") + "%", bgcolor=bullScoreColor, text_color=color.white, text_size=size.small)
    
    bearScoreColor = bearishScore >= 90 ? color.red : bearishScore >= 70 ? color.orange : color.gray
    table.cell(dashboard, 0, 6, "Bear Score", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 6, str.tostring(bearishScore, "#") + "%", bgcolor=bearScoreColor, text_color=color.white, text_size=size.small)
    
    // Confluence Factors
    table.cell(dashboard, 0, 7, "─── CONFLUENCE ───", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 7, "", text_color=color.gray, text_size=size.tiny)
    
    table.cell(dashboard, 0, 8, "Near Bull OB", text_color=color.white, text_size=size.tiny)
    table.cell(dashboard, 1, 8, nearBullishOB() ? "✓" : "✗", text_color=nearBullishOB() ? color.green : color.gray, text_size=size.tiny)
    
    table.cell(dashboard, 0, 9, "Near Bear OB", text_color=color.white, text_size=size.tiny)
    table.cell(dashboard, 1, 9, nearBearishOB() ? "✓" : "✗", text_color=nearBearishOB() ? color.red : color.gray, text_size=size.tiny)
    
    table.cell(dashboard, 0, 10, "Bull Sweep", text_color=color.white, text_size=size.tiny)
    table.cell(dashboard, 1, 10, bullishSweep ? "✓" : "✗", text_color=bullishSweep ? color.green : color.gray, text_size=size.tiny)
    
    table.cell(dashboard, 0, 11, "Bear Sweep", text_color=color.white, text_size=size.tiny)
    table.cell(dashboard, 1, 11, bearishSweep ? "✓" : "✗", text_color=bearishSweep ? color.red : color.gray, text_size=size.tiny)
    
    // Trade Parameters
    table.cell(dashboard, 0, 12, "─── TRADE PARAMS ───", text_color=color.gray, text_size=size.tiny)
    table.cell(dashboard, 1, 12, "", text_color=color.gray, text_size=size.tiny)
    
    table.cell(dashboard, 0, 13, "Rec. Leverage", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 13, str.tostring(practicalLeverage, "#") + "x", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)

// ══════════════════════════════════════════════════════════════════════════════
// ALERTS
// ══════════════════════════════════════════════════════════════════════════════

alertcondition(longCondition, title="Long Signal", message="SMC Ultra: LONG Signal - Score: {{plot_0}} - Entry: {{close}}")
alertcondition(shortCondition, title="Short Signal", message="SMC Ultra: SHORT Signal - Score: {{plot_0}} - Entry: {{close}}")

// Plot scores for alerts
plot(bullishScore, title="Bullish Score", display=display.none)
plot(bearishScore, title="Bearish Score", display=display.none)
